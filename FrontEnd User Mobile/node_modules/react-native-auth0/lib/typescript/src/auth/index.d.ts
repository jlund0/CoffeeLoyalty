import { Telemetry } from '../networking/telemetry';
import { AuthorizeUrlOptions, CreateUserOptions, Credentials, ExchangeNativeSocialOptions, ExchangeOptions, LoginWithEmailOptions, LoginWithOOBOptions, LoginWithOTPOptions, LoginWithRecoveryCodeOptions, LoginWithSMSOptions, LogoutUrlOptions, MultifactorChallengeOptions, MultifactorChallengeResponse, PasswordRealmOptions, PasswordlessWithEmailOptions, PasswordlessWithSMSOptions, RefreshTokenOptions, ResetPasswordOptions, RevokeOptions, User, UserInfoOptions } from '../types';
/**
 * Class for interfacing with the Auth0 Authentication API endpoints.
 *
 * @see https://auth0.com/docs/api/authentication
 */
declare class Auth {
    private client;
    /**
     * The Auth0 client ID
     */
    readonly clientId: string;
    /**
     * The Auth0 tenant domain
     */
    readonly domain: string;
    /**
     * @ignore
     */
    constructor(options: {
        baseUrl: string;
        clientId: string;
        telemetry?: Telemetry;
        token?: string;
        timeout?: number;
    });
    /**
     * Builds the full authorize endpoint url in the Authorization Server (AS) with given parameters.
     *
     * @returns A URL to the authorize endpoint with specified parameters to redirect to for AuthZ/AuthN.
     * @see https://auth0.com/docs/api/authentication#authorize-client
     */
    authorizeUrl(parameters: AuthorizeUrlOptions): string;
    /**
     * Builds the full logout endpoint url in the Authorization Server (AS) with given parameters.
     *
     * @returns A URL to the logout endpoint with specified parameters
     * @see https://auth0.com/docs/api/authentication#logout
     */
    logoutUrl(parameters: LogoutUrlOptions): string;
    /**
     * Exchanges a code obtained via `/authorize` (w/PKCE) for the user's tokens
     *
     * @returns A prominse for a populated instance of {@link Credentials}.
     * @see https://auth0.com/docs/api-auth/grant/authorization-code-pkce
     */
    exchange(parameters: ExchangeOptions): Promise<Credentials>;
    /**
     * Exchanges an external token obtained via a native social authentication solution for the user's tokens
     *
     * @returns A populated instance of {@link Credentials}.
     * @see https://auth0.com/docs/api/authentication#token-exchange-for-native-social
     */
    exchangeNativeSocial(parameters: ExchangeNativeSocialOptions): Promise<Credentials>;
    /**
     * Performs Auth with user credentials using the Password Realm Grant
     *
     * @returns A populated instance of {@link Credentials}.
     * @see https://auth0.com/docs/api-auth/grant/password#realm-support
     */
    passwordRealm(parameters: PasswordRealmOptions): Promise<Credentials>;
    /**
     * Obtain new tokens using the Refresh Token obtained during Auth (requesting `offline_access` scope)
     *
     * @returns A populated instance of {@link Credentials}.
     * @see https://auth0.com/docs/tokens/refresh-token/current#use-a-refresh-token
     */
    refreshToken(parameters: RefreshTokenOptions): Promise<Credentials>;
    /**
     * Starts the Passworldess flow with an email connection.
     *
     * This should be completed later using a call to {@link loginWithEmail}, passing the OTP that was sent to the user.
     */
    passwordlessWithEmail(parameters: PasswordlessWithEmailOptions): Promise<void>;
    /**
     * Starts the Passwordless flow with an SMS connection.
     *
     * This should be completed later using a call to {@link loginWithSMS}, passing the OTP that was sent to the user.
     */
    passwordlessWithSMS(parameters: PasswordlessWithSMSOptions): Promise<void>;
    /**
     * Completes the Passworldess authentication with an email connection that was started using {@link passwordlessWithEmail}.
     *
     * @returns A populated instance of {@link Credentials}.
     */
    loginWithEmail(parameters: LoginWithEmailOptions): Promise<Credentials>;
    /**
     * Completes the Passworldess authentication with an SMS connection that was started using {@link passwordlessWithSMS}.
     *
     * @returns A populated instance of {@link Credentials}.
     */
    loginWithSMS(parameters: LoginWithSMSOptions): Promise<Credentials>;
    /**
     * Log in a user using the One Time Password code after they have received the 'mfa_required' error.
     * The MFA token tells the server the username or email, password, and realm values sent on the first request.
     *
     * Requires your client to have the **MFA OTP** Grant Type enabled.
     * See [Client Grant Types](https://auth0.com/docs/clients/client-grant-types) to learn how to enable it.
     *
     * @returns A populated instance of {@link Credentials}.
     */
    loginWithOTP(parameters: LoginWithOTPOptions): Promise<Credentials>;
    /**
     * Log in a user using an Out Of Band authentication code after they have received the 'mfa_required' error.
     * The MFA token tells the server the username or email, password, and realm values sent on the first request.
     *
     * Requires your client to have the **MFA OOB** Grant Type enabled. See [Client Grant Types](https://auth0.com/docs/clients/client-grant-types) to learn how to enable it.
     *
     * @returns A populated instance of {@link Credentials}.
     */
    loginWithOOB(parameters: LoginWithOOBOptions): Promise<Credentials>;
    /**
     * Log in a user using a multi-factor authentication Recovery Code after they have received the 'mfa_required' error.
     * The MFA token tells the server the username or email, password, and realm values sent on the first request.
     *
     * Requires your client to have the **MFA** Grant Type enabled. See [Client Grant Types](https://auth0.com/docs/clients/client-grant-types) to learn how to enable it.
     *
     * @returns A populated instance of {@link Credentials}.
     */
    loginWithRecoveryCode(parameters: LoginWithRecoveryCodeOptions): Promise<Credentials>;
    /**
     * Request a challenge for multi-factor authentication (MFA) based on the challenge types supported by the application and user.
     * The challenge type is how the user will get the challenge and prove possession. Supported challenge types include: "otp" and "oob".
     *
     * @returns {@link MultifactorChallengeOTPResponse}, {@link MultifactorChallengeOOBResponse}, or {@link MultifactorChallengeOOBWithBindingResponse} depending
     * on the challenge type.
     */
    multifactorChallenge(parameters: MultifactorChallengeOptions): Promise<MultifactorChallengeResponse>;
    /**
     * Revoke an issued refresh token
     */
    revoke(parameters: RevokeOptions): Promise<void>;
    /**
     * Return user information using an access token
     *
     * @returns The user's profile information.
     */
    userInfo(parameters: UserInfoOptions): Promise<User>;
    /**
     * Request an email with instructions to change password of a user
     */
    resetPassword(parameters: ResetPasswordOptions): Promise<void>;
    /**
     * Creates a new user using the options provided.
     *
     * @returns An instance of {@link User}.
     */
    createUser(parameters: CreateUserOptions): Promise<Partial<User>>;
}
export default Auth;
//# sourceMappingURL=index.d.ts.map