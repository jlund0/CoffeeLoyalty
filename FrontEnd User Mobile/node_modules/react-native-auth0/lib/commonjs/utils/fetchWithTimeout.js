"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimeoutError = void 0;
exports.fetchWithTimeout = fetchWithTimeout;
var _baseError = _interopRequireDefault(require("./baseError"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class TimeoutError extends _baseError.default {
  constructor(msg) {
    super('TimeoutError', msg);
  }
}
exports.TimeoutError = TimeoutError;
function makeTimeout(timeoutMs) {
  let timerId = null;
  const promise = new Promise((_, reject) => {
    timerId = setTimeout(() => {
      reject(new TimeoutError('Timeout'));
    }, timeoutMs);
  });
  return {
    timerId: timerId,
    promise: promise
  };
}

/**
 * @private
 */
function fetchWithTimeout(url, options, timeoutMs) {
  const {
    promise: timeoutPromise,
    timerId
  } = makeTimeout(timeoutMs);
  const abortController = new AbortController();
  return Promise.race([fetch(url, {
    ...options,
    signal: abortController.signal
  }), timeoutPromise]).catch(error => {
    if (error instanceof TimeoutError) {
      abortController.abort();
    }
    throw error;
  }).then(response => {
    clearTimeout(timerId);
    return response;
  });
}
//# sourceMappingURL=fetchWithTimeout.js.map