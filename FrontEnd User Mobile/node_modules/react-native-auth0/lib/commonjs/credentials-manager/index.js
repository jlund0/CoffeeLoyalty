"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _reactNative = require("react-native");
var _credentialsManagerError = _interopRequireDefault(require("./credentialsManagerError"));
var _localAuthenticationStrategy = _interopRequireDefault(require("./localAuthenticationStrategy"));
var _nativeHelper = require("../utils/nativeHelper");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class CredentialsManager {
  /**
   * @ignore
   */
  constructor(domain, clientId) {
    this.domain = domain;
    this.clientId = clientId;
    this.Auth0Module = _reactNative.NativeModules.A0Auth0;
  }

  /**
   * Saves the provided credentials
   */
  async saveCredentials(credentials) {
    const validateKeys = ['idToken', 'accessToken', 'tokenType', 'expiresAt'];
    validateKeys.forEach(key => {
      if (!credentials[key]) {
        const json = {
          error: 'a0.credential_manager.invalid_input',
          error_description: `${key} cannot be empty`,
          invalid_parameter: key
        };
        throw new _credentialsManagerError.default({
          json,
          status: 0
        });
      }
    });
    try {
      await (0, _nativeHelper._ensureNativeModuleIsInitialized)(this.Auth0Module, this.clientId, this.domain);
      return await this.Auth0Module.saveCredentials(credentials);
    } catch (e) {
      const json = {
        error: 'a0.credential_manager.invalid',
        error_description: e.message
      };
      throw new _credentialsManagerError.default({
        json,
        status: 0
      });
    }
  }

  /**
   * Gets the credentials that has already been saved
   *
   * @param scope The scope to request for the access token. If null is passed, the previous scope will be kept.
   * @param minTtl The minimum time in seconds that the access token should last before expiration.
   * @param parameters Additional parameters to send in the request to refresh expired credentials.
   * @param forceRefresh Whether to force refresh the credentials. It will work only if the refresh token already exists. For iOS, doing forceRefresh will not send the scope and addtional parameters. Since scope change already does force refresh, it is better to avoid force refresh if the scope is being changed.
   * @returns A populated instance of {@link Credentials}.
   */
  async getCredentials(scope) {
    let minTtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let forceRefresh = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    try {
      await (0, _nativeHelper._ensureNativeModuleIsInitialized)(this.Auth0Module, this.clientId, this.domain);
      return this.Auth0Module.getCredentials(scope, minTtl, parameters, forceRefresh);
    } catch (e) {
      const json = {
        error: 'a0.credential_manager.invalid',
        error_description: e.message
      };
      throw new _credentialsManagerError.default({
        json,
        status: 0
      });
    }
  }

  /**
   * Enables Local Authentication (PIN, Biometric, Swipe etc) to get the credentials
   *
   * @param title the text to use as title in the authentication screen. Passing null will result in using the OS's default value in Android and "Please authenticate to continue" in iOS.
   * @param description **Android only:** the text to use as description in the authentication screen. On some Android versions it might not be shown. Passing null will result in using the OS's default value.
   * @param cancelTitle **iOS only:** the cancel message to display on the local authentication prompt.
   * @param fallbackTitle **iOS only:** the fallback message to display on the local authentication prompt after a failed match.
   * @param strategy **iOS only:** the evaluation policy to use when accessing the credentials. Defaults to LocalAuthenticationStrategy.deviceOwnerWithBiometrics.
   */
  async requireLocalAuthentication(title, description, cancelTitle, fallbackTitle) {
    let strategy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _localAuthenticationStrategy.default.deviceOwnerWithBiometrics;
    try {
      await (0, _nativeHelper._ensureNativeModuleIsInitialized)(this.Auth0Module, this.clientId, this.domain);
      if (_reactNative.Platform.OS === 'ios') {
        await this.Auth0Module.enableLocalAuthentication(title, cancelTitle, fallbackTitle, strategy);
      } else {
        await this.Auth0Module.enableLocalAuthentication(title, description);
      }
    } catch (e) {
      const json = {
        error: 'a0.credential_manager.invalid',
        error_description: e.message
      };
      throw new _credentialsManagerError.default({
        json,
        status: 0
      });
    }
  }

  /**
   * Returns whether this manager contains a valid non-expired pair of credentials.
   *
   * @param minTtl The minimum time in seconds that the access token should last before expiration
   * @returns `true` if a valid set of credentials are available, or `false` if there are no credentials to return.
   */
  async hasValidCredentials() {
    let minTtl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    await (0, _nativeHelper._ensureNativeModuleIsInitialized)(this.Auth0Module, this.clientId, this.domain);
    return await this.Auth0Module.hasValidCredentials(minTtl);
  }

  /**
   * Delete the stored credentials
   */
  async clearCredentials() {
    await (0, _nativeHelper._ensureNativeModuleIsInitialized)(this.Auth0Module, this.clientId, this.domain);
    return this.Auth0Module.clearCredentials();
  }
}
var _default = CredentialsManager;
exports.default = _default;
//# sourceMappingURL=index.js.map