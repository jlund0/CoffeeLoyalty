{"ast":null,"code":"'use strict';\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\nfunction C(aA1) {\n  return 3.0 * aA1;\n}\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\nfunction binarySubdivide(aX, _aA, _aB, mX1, mX2) {\n  var currentX,\n    currentT,\n    i = 0,\n    aA = _aA,\n    aB = _aB;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n  var aGuessT = _aGuessT;\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nexport default function bezier(mX1, mY1, mX2, mY2) {\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return function BezierEasing(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x;\n    }\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n}","map":{"version":3,"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","binarySubdivide","aX","_aA","_aB","mX1","mX2","currentX","currentT","i","aA","aB","Math","abs","newtonRaphsonIterate","_aGuessT","aGuessT","currentSlope","bezier","mY1","mY2","Error","sampleValues","Array","getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope","BezierEasing","x"],"sources":["D:/Users/julian/GIT/CoffeeLoyalty/FrontEnd User Mobile/node_modules/react-native/Libraries/Animated/bezier.js"],"sourcesContent":["/**\r\n * Portions Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict\r\n * @format\r\n */\r\n\r\n/**\r\n * BezierEasing - use bezier curve for transition easing function\r\n * https://github.com/gre/bezier-easing\r\n * @copyright 2014-2015 GaÃ«tan Renaudeau. MIT License.\r\n */\r\n\r\n'use strict';\r\n\r\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\r\nconst NEWTON_ITERATIONS = 4;\r\nconst NEWTON_MIN_SLOPE = 0.001;\r\nconst SUBDIVISION_PRECISION = 0.0000001;\r\nconst SUBDIVISION_MAX_ITERATIONS = 10;\r\n\r\nconst kSplineTableSize = 11;\r\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\r\n\r\nconst float32ArraySupported = typeof Float32Array === 'function';\r\n\r\nfunction A(aA1: number, aA2: number) {\r\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\r\n}\r\nfunction B(aA1: number, aA2: number) {\r\n  return 3.0 * aA2 - 6.0 * aA1;\r\n}\r\nfunction C(aA1: number) {\r\n  return 3.0 * aA1;\r\n}\r\n\r\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\r\nfunction calcBezier(aT: number, aA1: number, aA2: number) {\r\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\r\n}\r\n\r\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\r\nfunction getSlope(aT: number, aA1: number, aA2: number) {\r\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\r\n}\r\n\r\nfunction binarySubdivide(\r\n  aX: number,\r\n  _aA: number,\r\n  _aB: number,\r\n  mX1: number,\r\n  mX2: number,\r\n) {\r\n  let currentX,\r\n    currentT,\r\n    i = 0,\r\n    aA = _aA,\r\n    aB = _aB;\r\n  do {\r\n    currentT = aA + (aB - aA) / 2.0;\r\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\r\n    if (currentX > 0.0) {\r\n      aB = currentT;\r\n    } else {\r\n      aA = currentT;\r\n    }\r\n  } while (\r\n    Math.abs(currentX) > SUBDIVISION_PRECISION &&\r\n    ++i < SUBDIVISION_MAX_ITERATIONS\r\n  );\r\n  return currentT;\r\n}\r\n\r\nfunction newtonRaphsonIterate(\r\n  aX: number,\r\n  _aGuessT: number,\r\n  mX1: number,\r\n  mX2: number,\r\n) {\r\n  let aGuessT = _aGuessT;\r\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\r\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\r\n    if (currentSlope === 0.0) {\r\n      return aGuessT;\r\n    }\r\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\r\n    aGuessT -= currentX / currentSlope;\r\n  }\r\n  return aGuessT;\r\n}\r\n\r\nexport default function bezier(\r\n  mX1: number,\r\n  mY1: number,\r\n  mX2: number,\r\n  mY2: number,\r\n): (x: number) => number {\r\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\r\n    throw new Error('bezier x values must be in [0, 1] range');\r\n  }\r\n\r\n  // Precompute samples table\r\n  const sampleValues = float32ArraySupported\r\n    ? new Float32Array(kSplineTableSize)\r\n    : new Array<number>(kSplineTableSize);\r\n  if (mX1 !== mY1 || mX2 !== mY2) {\r\n    for (let i = 0; i < kSplineTableSize; ++i) {\r\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\r\n    }\r\n  }\r\n\r\n  function getTForX(aX: number) {\r\n    let intervalStart = 0.0;\r\n    let currentSample = 1;\r\n    const lastSample = kSplineTableSize - 1;\r\n\r\n    for (\r\n      ;\r\n      currentSample !== lastSample && sampleValues[currentSample] <= aX;\r\n      ++currentSample\r\n    ) {\r\n      intervalStart += kSampleStepSize;\r\n    }\r\n    --currentSample;\r\n\r\n    // Interpolate to provide an initial guess for t\r\n    const dist =\r\n      (aX - sampleValues[currentSample]) /\r\n      (sampleValues[currentSample + 1] - sampleValues[currentSample]);\r\n    const guessForT = intervalStart + dist * kSampleStepSize;\r\n\r\n    const initialSlope = getSlope(guessForT, mX1, mX2);\r\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\r\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\r\n    } else if (initialSlope === 0.0) {\r\n      return guessForT;\r\n    } else {\r\n      return binarySubdivide(\r\n        aX,\r\n        intervalStart,\r\n        intervalStart + kSampleStepSize,\r\n        mX1,\r\n        mX2,\r\n      );\r\n    }\r\n  }\r\n\r\n  return function BezierEasing(x: number): number {\r\n    if (mX1 === mY1 && mX2 === mY2) {\r\n      return x; // linear\r\n    }\r\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\r\n    if (x === 0) {\r\n      return 0;\r\n    }\r\n    if (x === 1) {\r\n      return 1;\r\n    }\r\n    return calcBezier(getTForX(x), mY1, mY2);\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}