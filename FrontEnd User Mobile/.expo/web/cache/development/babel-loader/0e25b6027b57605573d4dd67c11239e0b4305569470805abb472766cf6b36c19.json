{"ast":null,"code":"'use strict';\n\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nexport function elementsThatOverlapOffsets(offsets, props, getFrameMetrics) {\n  var zoomScale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var itemCount = props.getItemCount(props.data);\n  var result = [];\n  for (var offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {\n    var currentOffset = offsets[offsetIndex];\n    var left = 0;\n    var right = itemCount - 1;\n    while (left <= right) {\n      var mid = left + (right - left >>> 1);\n      var frame = getFrameMetrics(mid, props);\n      var scaledOffsetStart = frame.offset * zoomScale;\n      var scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;\n      if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart) {\n        right = mid - 1;\n      } else if (currentOffset > scaledOffsetEnd) {\n        left = mid + 1;\n      } else {\n        result[offsetIndex] = mid;\n        break;\n      }\n    }\n  }\n  return result;\n}\nexport function newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\nexport function computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {\n  var itemCount = props.getItemCount(props.data);\n  if (itemCount === 0) {\n    return {\n      first: 0,\n      last: -1\n    };\n  }\n  var offset = scrollMetrics.offset,\n    velocity = scrollMetrics.velocity,\n    visibleLength = scrollMetrics.visibleLength,\n    _scrollMetrics$zoomSc = scrollMetrics.zoomScale,\n    zoomScale = _scrollMetrics$zoomSc === void 0 ? 1 : _scrollMetrics$zoomSc;\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength;\n  var leadFactor = 0.5;\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1, props).offset * zoomScale;\n  if (lastItemOffset < overscanBegin) {\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  }\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props, getFrameMetricsApprox, zoomScale),\n    _elementsThatOverlapO2 = _slicedToArray(_elementsThatOverlapO, 4),\n    overscanFirst = _elementsThatOverlapO2[0],\n    first = _elementsThatOverlapO2[1],\n    last = _elementsThatOverlapO2[2],\n    overscanLast = _elementsThatOverlapO2[3];\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  };\n  var newCellCount = newRangeCount(prev, visible);\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      break;\n    }\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      break;\n    }\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n  return {\n    first: first,\n    last: last\n  };\n}\nexport function keyExtractor(item, index) {\n  if (typeof item === 'object' && (item == null ? void 0 : item.key) != null) {\n    return item.key;\n  }\n  if (typeof item === 'object' && (item == null ? void 0 : item.id) != null) {\n    return item.id;\n  }\n  return String(index);\n}","map":{"version":3,"names":["_slicedToArray","elementsThatOverlapOffsets","offsets","props","getFrameMetrics","zoomScale","arguments","length","undefined","itemCount","getItemCount","data","result","offsetIndex","currentOffset","left","right","mid","frame","scaledOffsetStart","offset","scaledOffsetEnd","newRangeCount","prev","next","last","first","Math","max","min","computeWindowedRenderLimits","maxToRenderPerBatch","windowSize","getFrameMetricsApprox","scrollMetrics","velocity","visibleLength","_scrollMetrics$zoomSc","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","_elementsThatOverlapO","_elementsThatOverlapO2","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","JSON","stringify","keyExtractor","item","index","key","id","String"],"sources":["D:/Users/julian/GIT/CoffeeLoyalty/FrontEnd User Mobile/node_modules/@react-native/virtualized-lists/Lists/VirtualizeUtils.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\n'use strict';\r\n\r\nimport type {FrameMetricProps} from './VirtualizedListProps';\r\n\r\n/**\r\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\r\n * items that bound different windows of content, such as the visible area or the buffered overscan\r\n * area.\r\n */\r\nexport function elementsThatOverlapOffsets(\r\n  offsets: Array<number>,\r\n  props: FrameMetricProps,\r\n  getFrameMetrics: (\r\n    index: number,\r\n    props: FrameMetricProps,\r\n  ) => {\r\n    length: number,\r\n    offset: number,\r\n    ...\r\n  },\r\n  zoomScale: number = 1,\r\n): Array<number> {\r\n  const itemCount = props.getItemCount(props.data);\r\n  const result = [];\r\n  for (let offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {\r\n    const currentOffset = offsets[offsetIndex];\r\n    let left = 0;\r\n    let right = itemCount - 1;\r\n\r\n    while (left <= right) {\r\n      // eslint-disable-next-line no-bitwise\r\n      const mid = left + ((right - left) >>> 1);\r\n      const frame = getFrameMetrics(mid, props);\r\n      const scaledOffsetStart = frame.offset * zoomScale;\r\n      const scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;\r\n\r\n      // We want the first frame that contains the offset, with inclusive bounds. Thus, for the\r\n      // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.\r\n      if (\r\n        (mid === 0 && currentOffset < scaledOffsetStart) ||\r\n        (mid !== 0 && currentOffset <= scaledOffsetStart)\r\n      ) {\r\n        right = mid - 1;\r\n      } else if (currentOffset > scaledOffsetEnd) {\r\n        left = mid + 1;\r\n      } else {\r\n        result[offsetIndex] = mid;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\r\n * Handy for calculating how many new items will be rendered when the render window changes so we\r\n * can restrict the number of new items render at once so that content can appear on the screen\r\n * faster.\r\n */\r\nexport function newRangeCount(\r\n  prev: {\r\n    first: number,\r\n    last: number,\r\n    ...\r\n  },\r\n  next: {\r\n    first: number,\r\n    last: number,\r\n    ...\r\n  },\r\n): number {\r\n  return (\r\n    next.last -\r\n    next.first +\r\n    1 -\r\n    Math.max(\r\n      0,\r\n      1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first),\r\n    )\r\n  );\r\n}\r\n\r\n/**\r\n * Custom logic for determining which items should be rendered given the current frame and scroll\r\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\r\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\r\n * biased in the direction of scroll.\r\n */\r\nexport function computeWindowedRenderLimits(\r\n  props: FrameMetricProps,\r\n  maxToRenderPerBatch: number,\r\n  windowSize: number,\r\n  prev: {\r\n    first: number,\r\n    last: number,\r\n  },\r\n  getFrameMetricsApprox: (\r\n    index: number,\r\n    props: FrameMetricProps,\r\n  ) => {\r\n    length: number,\r\n    offset: number,\r\n    ...\r\n  },\r\n  scrollMetrics: {\r\n    dt: number,\r\n    offset: number,\r\n    velocity: number,\r\n    visibleLength: number,\r\n    zoomScale: number,\r\n    ...\r\n  },\r\n): {\r\n  first: number,\r\n  last: number,\r\n} {\r\n  const itemCount = props.getItemCount(props.data);\r\n  if (itemCount === 0) {\r\n    return {first: 0, last: -1};\r\n  }\r\n  const {offset, velocity, visibleLength, zoomScale = 1} = scrollMetrics;\r\n\r\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\r\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\r\n  // too.\r\n  const visibleBegin = Math.max(0, offset);\r\n  const visibleEnd = visibleBegin + visibleLength;\r\n  const overscanLength = (windowSize - 1) * visibleLength;\r\n\r\n  // Considering velocity seems to introduce more churn than it's worth.\r\n  const leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\r\n\r\n  const fillPreference =\r\n    velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\r\n\r\n  const overscanBegin = Math.max(\r\n    0,\r\n    visibleBegin - (1 - leadFactor) * overscanLength,\r\n  );\r\n  const overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\r\n\r\n  const lastItemOffset =\r\n    getFrameMetricsApprox(itemCount - 1, props).offset * zoomScale;\r\n  if (lastItemOffset < overscanBegin) {\r\n    // Entire list is before our overscan window\r\n    return {\r\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\r\n      last: itemCount - 1,\r\n    };\r\n  }\r\n\r\n  // Find the indices that correspond to the items at the render boundaries we're targeting.\r\n  let [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets(\r\n    [overscanBegin, visibleBegin, visibleEnd, overscanEnd],\r\n    props,\r\n    getFrameMetricsApprox,\r\n    zoomScale,\r\n  );\r\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\r\n  first = first == null ? Math.max(0, overscanFirst) : first;\r\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\r\n  last =\r\n    last == null\r\n      ? Math.min(overscanLast, first + maxToRenderPerBatch - 1)\r\n      : last;\r\n  const visible = {first, last};\r\n\r\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\r\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\r\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\r\n  // render.\r\n  let newCellCount = newRangeCount(prev, visible);\r\n\r\n  while (true) {\r\n    if (first <= overscanFirst && last >= overscanLast) {\r\n      // If we fill the entire overscan range, we're done.\r\n      break;\r\n    }\r\n    const maxNewCells = newCellCount >= maxToRenderPerBatch;\r\n    const firstWillAddMore = first <= prev.first || first > prev.last;\r\n    const firstShouldIncrement =\r\n      first > overscanFirst && (!maxNewCells || !firstWillAddMore);\r\n    const lastWillAddMore = last >= prev.last || last < prev.first;\r\n    const lastShouldIncrement =\r\n      last < overscanLast && (!maxNewCells || !lastWillAddMore);\r\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\r\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\r\n      // without rendering new items. This let's us preserve as many already rendered items as\r\n      // possible, reducing render churn and keeping the rendered overscan range as large as\r\n      // possible.\r\n      break;\r\n    }\r\n    if (\r\n      firstShouldIncrement &&\r\n      !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)\r\n    ) {\r\n      if (firstWillAddMore) {\r\n        newCellCount++;\r\n      }\r\n      first--;\r\n    }\r\n    if (\r\n      lastShouldIncrement &&\r\n      !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)\r\n    ) {\r\n      if (lastWillAddMore) {\r\n        newCellCount++;\r\n      }\r\n      last++;\r\n    }\r\n  }\r\n  if (\r\n    !(\r\n      last >= first &&\r\n      first >= 0 &&\r\n      last < itemCount &&\r\n      first >= overscanFirst &&\r\n      last <= overscanLast &&\r\n      first <= visible.first &&\r\n      last >= visible.last\r\n    )\r\n  ) {\r\n    throw new Error(\r\n      'Bad window calculation ' +\r\n        JSON.stringify({\r\n          first,\r\n          last,\r\n          itemCount,\r\n          overscanFirst,\r\n          overscanLast,\r\n          visible,\r\n        }),\r\n    );\r\n  }\r\n  return {first, last};\r\n}\r\n\r\nexport function keyExtractor(item: any, index: number): string {\r\n  if (typeof item === 'object' && item?.key != null) {\r\n    return item.key;\r\n  }\r\n  if (typeof item === 'object' && item?.id != null) {\r\n    return item.id;\r\n  }\r\n  return String(index);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}