{"ast":null,"code":"import EventEmitter from \"../vendor/emitter/EventEmitter\";\nvar BatchedBridge = require(\"../BatchedBridge/BatchedBridge\");\nvar infoLog = require(\"../Utilities/infoLog\");\nvar TaskQueue = require(\"./TaskQueue\");\nvar invariant = require('invariant');\nvar _emitter = new EventEmitter();\nvar DEBUG_DELAY = 0;\nvar DEBUG = false;\nvar InteractionManager = {\n  Events: {\n    interactionStart: 'interactionStart',\n    interactionComplete: 'interactionComplete'\n  },\n  runAfterInteractions: function runAfterInteractions(task) {\n    var tasks = [];\n    var promise = new Promise(function (resolve) {\n      _scheduleUpdate();\n      if (task) {\n        tasks.push(task);\n      }\n      tasks.push({\n        run: resolve,\n        name: 'resolve ' + (task && task.name || '?')\n      });\n      _taskQueue.enqueueTasks(tasks);\n    });\n    return {\n      then: promise.then.bind(promise),\n      cancel: function cancel() {\n        _taskQueue.cancelTasks(tasks);\n      }\n    };\n  },\n  createInteractionHandle: function createInteractionHandle() {\n    DEBUG && infoLog('InteractionManager: create interaction handle');\n    _scheduleUpdate();\n    var handle = ++_inc;\n    _addInteractionSet.add(handle);\n    return handle;\n  },\n  clearInteractionHandle: function clearInteractionHandle(handle) {\n    DEBUG && infoLog('InteractionManager: clear interaction handle');\n    invariant(!!handle, 'InteractionManager: Must provide a handle to clear.');\n    _scheduleUpdate();\n    _addInteractionSet.delete(handle);\n    _deleteInteractionSet.add(handle);\n  },\n  addListener: _emitter.addListener.bind(_emitter),\n  setDeadline: function setDeadline(deadline) {\n    _deadline = deadline;\n  }\n};\nvar _interactionSet = new Set();\nvar _addInteractionSet = new Set();\nvar _deleteInteractionSet = new Set();\nvar _taskQueue = new TaskQueue({\n  onMoreTasks: _scheduleUpdate\n});\nvar _nextUpdateHandle = 0;\nvar _inc = 0;\nvar _deadline = -1;\nfunction _scheduleUpdate() {\n  if (!_nextUpdateHandle) {\n    if (_deadline > 0) {\n      _nextUpdateHandle = setTimeout(_processUpdate, 0 + DEBUG_DELAY);\n    } else {\n      _nextUpdateHandle = setImmediate(_processUpdate);\n    }\n  }\n}\nfunction _processUpdate() {\n  _nextUpdateHandle = 0;\n  var interactionCount = _interactionSet.size;\n  _addInteractionSet.forEach(function (handle) {\n    return _interactionSet.add(handle);\n  });\n  _deleteInteractionSet.forEach(function (handle) {\n    return _interactionSet.delete(handle);\n  });\n  var nextInteractionCount = _interactionSet.size;\n  if (interactionCount !== 0 && nextInteractionCount === 0) {\n    _emitter.emit(InteractionManager.Events.interactionComplete);\n  } else if (interactionCount === 0 && nextInteractionCount !== 0) {\n    _emitter.emit(InteractionManager.Events.interactionStart);\n  }\n  if (nextInteractionCount === 0) {\n    while (_taskQueue.hasTasksToProcess()) {\n      _taskQueue.processNext();\n      if (_deadline > 0 && BatchedBridge.getEventLoopRunningTime() >= _deadline) {\n        _scheduleUpdate();\n        break;\n      }\n    }\n  }\n  _addInteractionSet.clear();\n  _deleteInteractionSet.clear();\n}\nmodule.exports = InteractionManager;","map":{"version":3,"names":["EventEmitter","BatchedBridge","require","infoLog","TaskQueue","invariant","_emitter","DEBUG_DELAY","DEBUG","InteractionManager","Events","interactionStart","interactionComplete","runAfterInteractions","task","tasks","promise","Promise","resolve","_scheduleUpdate","push","run","name","_taskQueue","enqueueTasks","then","bind","cancel","cancelTasks","createInteractionHandle","handle","_inc","_addInteractionSet","add","clearInteractionHandle","delete","_deleteInteractionSet","addListener","setDeadline","deadline","_deadline","_interactionSet","Set","onMoreTasks","_nextUpdateHandle","setTimeout","_processUpdate","setImmediate","interactionCount","size","forEach","nextInteractionCount","emit","hasTasksToProcess","processNext","getEventLoopRunningTime","clear","module","exports"],"sources":["D:/Users/julian/GIT/CoffeeLoyalty/FrontEnd User Mobile/node_modules/react-native/Libraries/Interaction/InteractionManager.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * @flow strict-local\r\n */\r\n\r\nimport type {Task} from './TaskQueue';\r\n\r\nimport EventEmitter from '../vendor/emitter/EventEmitter';\r\n\r\nconst BatchedBridge = require('../BatchedBridge/BatchedBridge');\r\nconst infoLog = require('../Utilities/infoLog');\r\nconst TaskQueue = require('./TaskQueue');\r\nconst invariant = require('invariant');\r\n\r\nexport type Handle = number;\r\n\r\nconst _emitter = new EventEmitter<{\r\n  interactionComplete: [],\r\n  interactionStart: [],\r\n}>();\r\n\r\nconst DEBUG_DELAY: 0 = 0;\r\nconst DEBUG: false = false;\r\n\r\n/**\r\n * InteractionManager allows long-running work to be scheduled after any\r\n * interactions/animations have completed. In particular, this allows JavaScript\r\n * animations to run smoothly.\r\n *\r\n * Applications can schedule tasks to run after interactions with the following:\r\n *\r\n * ```\r\n * InteractionManager.runAfterInteractions(() => {\r\n *   // ...long-running synchronous task...\r\n * });\r\n * ```\r\n *\r\n * Compare this to other scheduling alternatives:\r\n *\r\n * - requestAnimationFrame(): for code that animates a view over time.\r\n * - setImmediate/setTimeout(): run code later, note this may delay animations.\r\n * - runAfterInteractions(): run code later, without delaying active animations.\r\n *\r\n * The touch handling system considers one or more active touches to be an\r\n * 'interaction' and will delay `runAfterInteractions()` callbacks until all\r\n * touches have ended or been cancelled.\r\n *\r\n * InteractionManager also allows applications to register animations by\r\n * creating an interaction 'handle' on animation start, and clearing it upon\r\n * completion:\r\n *\r\n * ```\r\n * var handle = InteractionManager.createInteractionHandle();\r\n * // run animation... (`runAfterInteractions` tasks are queued)\r\n * // later, on animation completion:\r\n * InteractionManager.clearInteractionHandle(handle);\r\n * // queued tasks run if all handles were cleared\r\n * ```\r\n *\r\n * `runAfterInteractions` takes either a plain callback function, or a\r\n * `PromiseTask` object with a `gen` method that returns a `Promise`.  If a\r\n * `PromiseTask` is supplied, then it is fully resolved (including asynchronous\r\n * dependencies that also schedule more tasks via `runAfterInteractions`) before\r\n * starting on the next task that might have been queued up synchronously\r\n * earlier.\r\n *\r\n * By default, queued tasks are executed together in a loop in one\r\n * `setImmediate` batch. If `setDeadline` is called with a positive number, then\r\n * tasks will only be executed until the deadline (in terms of js event loop run\r\n * time) approaches, at which point execution will yield via setTimeout,\r\n * allowing events such as touches to start interactions and block queued tasks\r\n * from executing, making apps more responsive.\r\n */\r\nconst InteractionManager = {\r\n  Events: {\r\n    interactionStart: 'interactionStart',\r\n    interactionComplete: 'interactionComplete',\r\n  },\r\n\r\n  /**\r\n   * Schedule a function to run after all interactions have completed. Returns a cancellable\r\n   * \"promise\".\r\n   */\r\n  runAfterInteractions(task: ?Task): {\r\n    then: <U>(\r\n      onFulfill?: ?(void) => ?(Promise<U> | U),\r\n      onReject?: ?(error: mixed) => ?(Promise<U> | U),\r\n    ) => Promise<U>,\r\n    cancel: () => void,\r\n    ...\r\n  } {\r\n    const tasks: Array<Task> = [];\r\n    const promise = new Promise((resolve: () => void) => {\r\n      _scheduleUpdate();\r\n      if (task) {\r\n        tasks.push(task);\r\n      }\r\n      tasks.push({\r\n        run: resolve,\r\n        name: 'resolve ' + ((task && task.name) || '?'),\r\n      });\r\n      _taskQueue.enqueueTasks(tasks);\r\n    });\r\n    return {\r\n      // $FlowFixMe[method-unbinding] added when improving typing for this parameters\r\n      then: promise.then.bind(promise),\r\n      cancel: function () {\r\n        _taskQueue.cancelTasks(tasks);\r\n      },\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Notify manager that an interaction has started.\r\n   */\r\n  createInteractionHandle(): Handle {\r\n    DEBUG && infoLog('InteractionManager: create interaction handle');\r\n    _scheduleUpdate();\r\n    const handle = ++_inc;\r\n    _addInteractionSet.add(handle);\r\n    return handle;\r\n  },\r\n\r\n  /**\r\n   * Notify manager that an interaction has completed.\r\n   */\r\n  clearInteractionHandle(handle: Handle) {\r\n    DEBUG && infoLog('InteractionManager: clear interaction handle');\r\n    invariant(!!handle, 'InteractionManager: Must provide a handle to clear.');\r\n    _scheduleUpdate();\r\n    _addInteractionSet.delete(handle);\r\n    _deleteInteractionSet.add(handle);\r\n  },\r\n\r\n  // $FlowFixMe[method-unbinding] added when improving typing for this parameters\r\n  addListener: (_emitter.addListener.bind(_emitter): $FlowFixMe),\r\n\r\n  /**\r\n   * A positive number will use setTimeout to schedule any tasks after the\r\n   * eventLoopRunningTime hits the deadline value, otherwise all tasks will be\r\n   * executed in one setImmediate batch (default).\r\n   */\r\n  setDeadline(deadline: number) {\r\n    _deadline = deadline;\r\n  },\r\n};\r\n\r\nconst _interactionSet = new Set<number | Handle>();\r\nconst _addInteractionSet = new Set<number | Handle>();\r\nconst _deleteInteractionSet = new Set<Handle>();\r\nconst _taskQueue = new TaskQueue({onMoreTasks: _scheduleUpdate});\r\nlet _nextUpdateHandle: $FlowFixMe | TimeoutID = 0;\r\nlet _inc = 0;\r\nlet _deadline = -1;\r\n\r\n/**\r\n * Schedule an asynchronous update to the interaction state.\r\n */\r\nfunction _scheduleUpdate() {\r\n  if (!_nextUpdateHandle) {\r\n    if (_deadline > 0) {\r\n      _nextUpdateHandle = setTimeout(_processUpdate, 0 + DEBUG_DELAY);\r\n    } else {\r\n      _nextUpdateHandle = setImmediate(_processUpdate);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Notify listeners, process queue, etc\r\n */\r\nfunction _processUpdate() {\r\n  _nextUpdateHandle = 0;\r\n\r\n  const interactionCount = _interactionSet.size;\r\n  _addInteractionSet.forEach(handle => _interactionSet.add(handle));\r\n  _deleteInteractionSet.forEach(handle => _interactionSet.delete(handle));\r\n  const nextInteractionCount = _interactionSet.size;\r\n\r\n  if (interactionCount !== 0 && nextInteractionCount === 0) {\r\n    // transition from 1+ --> 0 interactions\r\n    _emitter.emit(InteractionManager.Events.interactionComplete);\r\n  } else if (interactionCount === 0 && nextInteractionCount !== 0) {\r\n    // transition from 0 --> 1+ interactions\r\n    _emitter.emit(InteractionManager.Events.interactionStart);\r\n  }\r\n\r\n  // process the queue regardless of a transition\r\n  if (nextInteractionCount === 0) {\r\n    while (_taskQueue.hasTasksToProcess()) {\r\n      _taskQueue.processNext();\r\n      if (\r\n        _deadline > 0 &&\r\n        BatchedBridge.getEventLoopRunningTime() >= _deadline\r\n      ) {\r\n        // Hit deadline before processing all tasks, so process more later.\r\n        _scheduleUpdate();\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  _addInteractionSet.clear();\r\n  _deleteInteractionSet.clear();\r\n}\r\n\r\nmodule.exports = InteractionManager;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}