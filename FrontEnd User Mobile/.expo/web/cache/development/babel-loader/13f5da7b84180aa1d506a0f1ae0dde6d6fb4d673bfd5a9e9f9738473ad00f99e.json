{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport Animated from \"../../Animated/Animated\";\nimport { isPublicInstance as isFabricPublicInstance } from \"../../Renderer/public/ReactFabricPublicInstanceUtils\";\nimport StyleSheet from \"../../StyleSheet/StyleSheet\";\nimport Platform from \"../../Utilities/Platform\";\nimport useMergeRefs from \"../../Utilities/useMergeRefs\";\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar ScrollViewStickyHeaderWithForwardedRef = React.forwardRef(function ScrollViewStickyHeader(props, forwardedRef) {\n  var inverted = props.inverted,\n    scrollViewHeight = props.scrollViewHeight,\n    hiddenOnScroll = props.hiddenOnScroll,\n    scrollAnimatedValue = props.scrollAnimatedValue,\n    _nextHeaderLayoutY = props.nextHeaderLayoutY;\n  var _useState = useState(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    measured = _useState2[0],\n    setMeasured = _useState2[1];\n  var _useState3 = useState(0),\n    _useState4 = _slicedToArray(_useState3, 2),\n    layoutY = _useState4[0],\n    setLayoutY = _useState4[1];\n  var _useState5 = useState(0),\n    _useState6 = _slicedToArray(_useState5, 2),\n    layoutHeight = _useState6[0],\n    setLayoutHeight = _useState6[1];\n  var _useState7 = useState(null),\n    _useState8 = _slicedToArray(_useState7, 2),\n    translateY = _useState8[0],\n    setTranslateY = _useState8[1];\n  var _useState9 = useState(_nextHeaderLayoutY),\n    _useState10 = _slicedToArray(_useState9, 2),\n    nextHeaderLayoutY = _useState10[0],\n    setNextHeaderLayoutY = _useState10[1];\n  var _useState11 = useState(false),\n    _useState12 = _slicedToArray(_useState11, 2),\n    isFabric = _useState12[0],\n    setIsFabric = _useState12[1];\n  var callbackRef = function callbackRef(ref) {\n    if (ref == null) {\n      return;\n    }\n    ref.setNextHeaderY = function (value) {\n      setNextHeaderLayoutY(value);\n    };\n    setIsFabric(isFabricPublicInstance(ref));\n  };\n  var ref = useMergeRefs(callbackRef, forwardedRef);\n  var offset = useMemo(function () {\n    return hiddenOnScroll === true ? Animated.diffClamp(scrollAnimatedValue.interpolate({\n      extrapolateLeft: 'clamp',\n      inputRange: [layoutY, layoutY + 1],\n      outputRange: [0, 1]\n    }).interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, -1]\n    }), -layoutHeight, 0) : null;\n  }, [scrollAnimatedValue, layoutHeight, layoutY, hiddenOnScroll]);\n  var _useState13 = useState(function () {\n      var inputRange = [-1, 0];\n      var outputRange = [0, 0];\n      var initialTranslateY = scrollAnimatedValue.interpolate({\n        inputRange: inputRange,\n        outputRange: outputRange\n      });\n      if (offset != null) {\n        return Animated.add(initialTranslateY, offset);\n      }\n      return initialTranslateY;\n    }),\n    _useState14 = _slicedToArray(_useState13, 2),\n    animatedTranslateY = _useState14[0],\n    setAnimatedTranslateY = _useState14[1];\n  var _haveReceivedInitialZeroTranslateY = useRef(true);\n  var _timer = useRef(null);\n  useEffect(function () {\n    if (translateY !== 0 && translateY != null) {\n      _haveReceivedInitialZeroTranslateY.current = false;\n    }\n  }, [translateY]);\n  var animatedValueListener = useCallback(function (_ref) {\n    var value = _ref.value;\n    var _debounceTimeout = Platform.OS === 'android' ? 15 : 64;\n    if (value === 0 && !_haveReceivedInitialZeroTranslateY.current) {\n      _haveReceivedInitialZeroTranslateY.current = true;\n      return;\n    }\n    if (_timer.current != null) {\n      clearTimeout(_timer.current);\n    }\n    _timer.current = setTimeout(function () {\n      if (value !== translateY) {\n        setTranslateY(value);\n      }\n    }, _debounceTimeout);\n  }, [translateY]);\n  useEffect(function () {\n    var inputRange = [-1, 0];\n    var outputRange = [0, 0];\n    if (measured) {\n      if (inverted === true) {\n        if (scrollViewHeight != null) {\n          var stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            var collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(collisionPoint - stickStartPoint, collisionPoint - stickStartPoint);\n            }\n          }\n        }\n      } else {\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        var _collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (_collisionPoint >= layoutY) {\n          inputRange.push(_collisionPoint, _collisionPoint + 1);\n          outputRange.push(_collisionPoint - layoutY, _collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n    var newAnimatedTranslateY = scrollAnimatedValue.interpolate({\n      inputRange: inputRange,\n      outputRange: outputRange\n    });\n    if (offset != null) {\n      newAnimatedTranslateY = Animated.add(newAnimatedTranslateY, offset);\n    }\n    var animatedListenerId;\n    if (isFabric) {\n      animatedListenerId = newAnimatedTranslateY.addListener(animatedValueListener);\n    }\n    setAnimatedTranslateY(newAnimatedTranslateY);\n    return function () {\n      if (animatedListenerId) {\n        newAnimatedTranslateY.removeListener(animatedListenerId);\n      }\n      if (_timer.current != null) {\n        clearTimeout(_timer.current);\n      }\n    };\n  }, [nextHeaderLayoutY, measured, layoutHeight, layoutY, scrollViewHeight, scrollAnimatedValue, inverted, offset, animatedValueListener, isFabric]);\n  var _onLayout = function _onLayout(event) {\n    setLayoutY(event.nativeEvent.layout.y);\n    setLayoutHeight(event.nativeEvent.layout.height);\n    setMeasured(true);\n    props.onLayout(event);\n    var child = React.Children.only(props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n  var child = React.Children.only(props.children);\n  var passthroughAnimatedPropExplicitValues = isFabric && translateY != null ? {\n    style: {\n      transform: [{\n        translateY: translateY\n      }]\n    }\n  } : null;\n  return _jsx(Animated.View, {\n    collapsable: false,\n    nativeID: props.nativeID,\n    onLayout: _onLayout,\n    ref: ref,\n    style: [child.props.style, styles.header, {\n      transform: [{\n        translateY: animatedTranslateY\n      }]\n    }],\n    passthroughAnimatedPropExplicitValues: passthroughAnimatedPropExplicitValues,\n    children: React.cloneElement(child, {\n      style: styles.fill,\n      onLayout: undefined\n    })\n  });\n});\nvar styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n    position: 'relative'\n  },\n  fill: {\n    flex: 1\n  }\n});\nexport default ScrollViewStickyHeaderWithForwardedRef;","map":{"version":3,"names":["Animated","isPublicInstance","isFabricPublicInstance","StyleSheet","Platform","useMergeRefs","React","useCallback","useEffect","useMemo","useRef","useState","jsx","_jsx","ScrollViewStickyHeaderWithForwardedRef","forwardRef","ScrollViewStickyHeader","props","forwardedRef","inverted","scrollViewHeight","hiddenOnScroll","scrollAnimatedValue","_nextHeaderLayoutY","nextHeaderLayoutY","_useState","_useState2","_slicedToArray","measured","setMeasured","_useState3","_useState4","layoutY","setLayoutY","_useState5","_useState6","layoutHeight","setLayoutHeight","_useState7","_useState8","translateY","setTranslateY","_useState9","_useState10","setNextHeaderLayoutY","_useState11","_useState12","isFabric","setIsFabric","callbackRef","ref","setNextHeaderY","value","offset","diffClamp","interpolate","extrapolateLeft","inputRange","outputRange","_useState13","initialTranslateY","add","_useState14","animatedTranslateY","setAnimatedTranslateY","_haveReceivedInitialZeroTranslateY","_timer","current","animatedValueListener","_ref","_debounceTimeout","OS","clearTimeout","setTimeout","stickStartPoint","push","collisionPoint","newAnimatedTranslateY","animatedListenerId","addListener","removeListener","_onLayout","event","nativeEvent","layout","y","height","onLayout","child","Children","only","children","passthroughAnimatedPropExplicitValues","style","transform","View","collapsable","nativeID","styles","header","cloneElement","fill","undefined","create","zIndex","position","flex"],"sources":["D:/Users/julian/GIT/CoffeeLoyalty/FrontEnd User Mobile/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\r\n\r\nimport Animated from '../../Animated/Animated';\r\nimport {isPublicInstance as isFabricPublicInstance} from '../../Renderer/public/ReactFabricPublicInstanceUtils';\r\nimport StyleSheet from '../../StyleSheet/StyleSheet';\r\nimport Platform from '../../Utilities/Platform';\r\nimport useMergeRefs from '../../Utilities/useMergeRefs';\r\nimport * as React from 'react';\r\nimport {useCallback, useEffect, useMemo, useRef, useState} from 'react';\r\n\r\nexport type Props = $ReadOnly<{\r\n  children?: React.Element<$FlowFixMe>,\r\n  nextHeaderLayoutY: ?number,\r\n  onLayout: (event: LayoutEvent) => void,\r\n  scrollAnimatedValue: Animated.Value,\r\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\r\n  // of the top.\r\n  inverted: ?boolean,\r\n  // The height of the parent ScrollView. Currently only set when inverted.\r\n  scrollViewHeight: ?number,\r\n  nativeID?: ?string,\r\n  hiddenOnScroll?: ?boolean,\r\n}>;\r\n\r\ntype Instance = {\r\n  ...React.ElementRef<typeof Animated.View>,\r\n  setNextHeaderY: number => void,\r\n  ...\r\n};\r\n\r\nconst ScrollViewStickyHeaderWithForwardedRef: React.AbstractComponent<\r\n  Props,\r\n  Instance,\r\n> = React.forwardRef(function ScrollViewStickyHeader(props, forwardedRef) {\r\n  const {\r\n    inverted,\r\n    scrollViewHeight,\r\n    hiddenOnScroll,\r\n    scrollAnimatedValue,\r\n    nextHeaderLayoutY: _nextHeaderLayoutY,\r\n  } = props;\r\n\r\n  const [measured, setMeasured] = useState<boolean>(false);\r\n  const [layoutY, setLayoutY] = useState<number>(0);\r\n  const [layoutHeight, setLayoutHeight] = useState<number>(0);\r\n  const [translateY, setTranslateY] = useState<?number>(null);\r\n  const [nextHeaderLayoutY, setNextHeaderLayoutY] =\r\n    useState<?number>(_nextHeaderLayoutY);\r\n  const [isFabric, setIsFabric] = useState<boolean>(false);\r\n\r\n  const callbackRef = (ref: Instance | null): void => {\r\n    if (ref == null) {\r\n      return;\r\n    }\r\n    ref.setNextHeaderY = value => {\r\n      setNextHeaderLayoutY(value);\r\n    };\r\n    setIsFabric(isFabricPublicInstance(ref));\r\n  };\r\n  const ref: (React.ElementRef<typeof Animated.View> | null) => void =\r\n    // $FlowFixMe[incompatible-type] - Ref is mutated by `callbackRef`.\r\n    useMergeRefs<Instance | null>(callbackRef, forwardedRef);\r\n\r\n  const offset = useMemo(\r\n    () =>\r\n      hiddenOnScroll === true\r\n        ? Animated.diffClamp(\r\n            scrollAnimatedValue\r\n              .interpolate({\r\n                extrapolateLeft: 'clamp',\r\n                inputRange: [layoutY, layoutY + 1],\r\n                outputRange: ([0, 1]: Array<number>),\r\n              })\r\n              .interpolate({\r\n                inputRange: [0, 1],\r\n                outputRange: ([0, -1]: Array<number>),\r\n              }),\r\n            -layoutHeight,\r\n            0,\r\n          )\r\n        : null,\r\n    [scrollAnimatedValue, layoutHeight, layoutY, hiddenOnScroll],\r\n  );\r\n\r\n  const [animatedTranslateY, setAnimatedTranslateY] = useState<Animated.Node>(\r\n    () => {\r\n      const inputRange: Array<number> = [-1, 0];\r\n      const outputRange: Array<number> = [0, 0];\r\n      const initialTranslateY = scrollAnimatedValue.interpolate({\r\n        inputRange,\r\n        outputRange,\r\n      });\r\n\r\n      if (offset != null) {\r\n        return Animated.add(initialTranslateY, offset);\r\n      }\r\n      return initialTranslateY;\r\n    },\r\n  );\r\n\r\n  const _haveReceivedInitialZeroTranslateY = useRef<boolean>(true);\r\n  const _timer = useRef<?TimeoutID>(null);\r\n\r\n  useEffect(() => {\r\n    if (translateY !== 0 && translateY != null) {\r\n      _haveReceivedInitialZeroTranslateY.current = false;\r\n    }\r\n  }, [translateY]);\r\n\r\n  // This is called whenever the (Interpolated) Animated Value\r\n  // updates, which is several times per frame during scrolling.\r\n  // To ensure that the Fabric ShadowTree has the most recent\r\n  // translate style of this node, we debounce the value and then\r\n  // pass it through to the underlying node during render.\r\n  // This is:\r\n  // 1. Only an issue in Fabric.\r\n  // 2. Worse in Android than iOS. In Android, but not iOS, you\r\n  //    can touch and move your finger slightly and still trigger\r\n  //    a \"tap\" event. In iOS, moving will cancel the tap in\r\n  //    both Fabric and non-Fabric. On Android when you move\r\n  //    your finger, the hit-detection moves from the Android\r\n  //    platform to JS, so we need the ShadowTree to have knowledge\r\n  //    of the current position.\r\n  const animatedValueListener = useCallback(\r\n    ({value}: $FlowFixMe) => {\r\n      const _debounceTimeout: number = Platform.OS === 'android' ? 15 : 64;\r\n      // When the AnimatedInterpolation is recreated, it always initializes\r\n      // to a value of zero and emits a value change of 0 to its listeners.\r\n      if (value === 0 && !_haveReceivedInitialZeroTranslateY.current) {\r\n        _haveReceivedInitialZeroTranslateY.current = true;\r\n        return;\r\n      }\r\n      if (_timer.current != null) {\r\n        clearTimeout(_timer.current);\r\n      }\r\n      _timer.current = setTimeout(() => {\r\n        if (value !== translateY) {\r\n          setTranslateY(value);\r\n        }\r\n      }, _debounceTimeout);\r\n    },\r\n    [translateY],\r\n  );\r\n\r\n  useEffect(() => {\r\n    const inputRange: Array<number> = [-1, 0];\r\n    const outputRange: Array<number> = [0, 0];\r\n\r\n    if (measured) {\r\n      if (inverted === true) {\r\n        // The interpolation looks like:\r\n        // - Negative scroll: no translation\r\n        // - `stickStartPoint` is the point at which the header will start sticking.\r\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\r\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\r\n        //   will be negative.\r\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\r\n        //   to scroll normally until it reaches the top of the scroll view.\r\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\r\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\r\n        // - Past the collision with the next header y: no more translation. This will cause the\r\n        //   header to continue scrolling up and make room for the next sticky header.\r\n        //   In the case that there is no next header just translate equally to\r\n        //   scroll indefinitely.\r\n        if (scrollViewHeight != null) {\r\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\r\n          if (stickStartPoint > 0) {\r\n            inputRange.push(stickStartPoint);\r\n            outputRange.push(0);\r\n            inputRange.push(stickStartPoint + 1);\r\n            outputRange.push(1);\r\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\r\n            // we can just keep it sticked forever.\r\n            const collisionPoint =\r\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\r\n            if (collisionPoint > stickStartPoint) {\r\n              inputRange.push(collisionPoint, collisionPoint + 1);\r\n              outputRange.push(\r\n                collisionPoint - stickStartPoint,\r\n                collisionPoint - stickStartPoint,\r\n              );\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // The interpolation looks like:\r\n        // - Negative scroll: no translation\r\n        // - From 0 to the y of the header: no translation. This will cause the header\r\n        //   to scroll normally until it reaches the top of the scroll view.\r\n        // - From header y to when the next header y hits the bottom edge of the header: translate\r\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\r\n        // - Past the collision with the next header y: no more translation. This will cause the\r\n        //   header to continue scrolling up and make room for the next sticky header.\r\n        //   In the case that there is no next header just translate equally to\r\n        //   scroll indefinitely.\r\n        inputRange.push(layoutY);\r\n        outputRange.push(0);\r\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\r\n        // we can just keep it sticked forever.\r\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\r\n        if (collisionPoint >= layoutY) {\r\n          inputRange.push(collisionPoint, collisionPoint + 1);\r\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\r\n        } else {\r\n          inputRange.push(layoutY + 1);\r\n          outputRange.push(1);\r\n        }\r\n      }\r\n    }\r\n\r\n    let newAnimatedTranslateY: Animated.Node = scrollAnimatedValue.interpolate({\r\n      inputRange,\r\n      outputRange,\r\n    });\r\n\r\n    if (offset != null) {\r\n      newAnimatedTranslateY = Animated.add(newAnimatedTranslateY, offset);\r\n    }\r\n\r\n    // add the event listener\r\n    let animatedListenerId;\r\n    if (isFabric) {\r\n      animatedListenerId = newAnimatedTranslateY.addListener(\r\n        animatedValueListener,\r\n      );\r\n    }\r\n\r\n    setAnimatedTranslateY(newAnimatedTranslateY);\r\n\r\n    // clean up the event listener and timer\r\n    return () => {\r\n      if (animatedListenerId) {\r\n        newAnimatedTranslateY.removeListener(animatedListenerId);\r\n      }\r\n      if (_timer.current != null) {\r\n        clearTimeout(_timer.current);\r\n      }\r\n    };\r\n  }, [nextHeaderLayoutY, measured, layoutHeight, layoutY, scrollViewHeight, scrollAnimatedValue, inverted, offset, animatedValueListener, isFabric]);\r\n\r\n  const _onLayout = (event: LayoutEvent) => {\r\n    setLayoutY(event.nativeEvent.layout.y);\r\n    setLayoutHeight(event.nativeEvent.layout.height);\r\n    setMeasured(true);\r\n\r\n    props.onLayout(event);\r\n    const child = React.Children.only<$FlowFixMe>(props.children);\r\n    if (child.props.onLayout) {\r\n      child.props.onLayout(event);\r\n    }\r\n  };\r\n\r\n  const child = React.Children.only<$FlowFixMe>(props.children);\r\n\r\n  // TODO T68319535: remove this if NativeAnimated is rewritten for Fabric\r\n  const passthroughAnimatedPropExplicitValues =\r\n    isFabric && translateY != null\r\n      ? {\r\n          style: {transform: [{translateY: translateY}]},\r\n        }\r\n      : null;\r\n\r\n  return (\r\n    /* $FlowFixMe[prop-missing] passthroughAnimatedPropExplicitValues isn't properly\r\n       included in the Animated.View flow type. */\r\n    <Animated.View\r\n      collapsable={false}\r\n      nativeID={props.nativeID}\r\n      onLayout={_onLayout}\r\n      ref={ref}\r\n      style={[\r\n        child.props.style,\r\n        styles.header,\r\n        {transform: [{translateY: animatedTranslateY}]},\r\n      ]}\r\n      passthroughAnimatedPropExplicitValues={\r\n        passthroughAnimatedPropExplicitValues\r\n      }>\r\n      {React.cloneElement(child, {\r\n        style: styles.fill, // We transfer the child style to the wrapper.\r\n        onLayout: undefined, // we call this manually through our this._onLayout\r\n      })}\r\n    </Animated.View>\r\n  );\r\n});\r\n\r\nconst styles = StyleSheet.create({\r\n  header: {\r\n    zIndex: 10,\r\n    position: 'relative',\r\n  },\r\n  fill: {\r\n    flex: 1,\r\n  },\r\n});\r\n\r\nexport default ScrollViewStickyHeaderWithForwardedRef;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}