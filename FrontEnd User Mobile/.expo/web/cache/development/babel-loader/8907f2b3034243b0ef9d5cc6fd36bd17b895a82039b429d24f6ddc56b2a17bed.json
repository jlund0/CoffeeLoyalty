{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport NativePerformanceObserver from \"./NativePerformanceObserver\";\nimport { warnNoNativePerformanceObserver } from \"./PerformanceObserver\";\nvar cachedEventCounts;\nfunction getCachedEventCounts() {\n  var _cachedEventCounts;\n  if (cachedEventCounts) {\n    return cachedEventCounts;\n  }\n  if (!NativePerformanceObserver) {\n    warnNoNativePerformanceObserver();\n    return new Map();\n  }\n  cachedEventCounts = new Map(NativePerformanceObserver.getEventCounts());\n  global.queueMicrotask(function () {\n    cachedEventCounts = null;\n  });\n  return (_cachedEventCounts = cachedEventCounts) != null ? _cachedEventCounts : new Map();\n}\nvar EventCounts = function () {\n  function EventCounts() {\n    _classCallCheck(this, EventCounts);\n  }\n  _createClass(EventCounts, [{\n    key: \"size\",\n    get: function get() {\n      return getCachedEventCounts().size;\n    }\n  }, {\n    key: \"entries\",\n    value: function entries() {\n      return getCachedEventCounts().entries();\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      return getCachedEventCounts().forEach(callback);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return getCachedEventCounts().get(key);\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return getCachedEventCounts().has(key);\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return getCachedEventCounts().keys();\n    }\n  }, {\n    key: \"values\",\n    value: function values() {\n      return getCachedEventCounts().values();\n    }\n  }]);\n  return EventCounts;\n}();\nexport { EventCounts as default };","map":{"version":3,"names":["NativePerformanceObserver","warnNoNativePerformanceObserver","cachedEventCounts","getCachedEventCounts","_cachedEventCounts","Map","getEventCounts","global","queueMicrotask","EventCounts","_classCallCheck","_createClass","key","get","size","value","entries","forEach","callback","has","keys","values","default"],"sources":["D:/Users/julian/GIT/CoffeeLoyalty/FrontEnd User Mobile/node_modules/react-native/Libraries/WebPerformance/EventCounts.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict\r\n * @format\r\n */\r\n\r\nimport NativePerformanceObserver from './NativePerformanceObserver';\r\nimport {warnNoNativePerformanceObserver} from './PerformanceObserver';\r\n\r\ntype EventCountsForEachCallbackType =\r\n  | (() => void)\r\n  | ((value: number) => void)\r\n  | ((value: number, key: string) => void)\r\n  | ((value: number, key: string, map: Map<string, number>) => void);\r\n\r\nlet cachedEventCounts: ?Map<string, number>;\r\n\r\nfunction getCachedEventCounts(): Map<string, number> {\r\n  if (cachedEventCounts) {\r\n    return cachedEventCounts;\r\n  }\r\n  if (!NativePerformanceObserver) {\r\n    warnNoNativePerformanceObserver();\r\n    return new Map();\r\n  }\r\n\r\n  cachedEventCounts = new Map<string, number>(\r\n    NativePerformanceObserver.getEventCounts(),\r\n  );\r\n  // $FlowFixMe[incompatible-call]\r\n  global.queueMicrotask(() => {\r\n    // To be consistent with the calls to the API from the same task,\r\n    // but also not to refetch the data from native too often,\r\n    // schedule to invalidate the cache later,\r\n    // after the current task is guaranteed to have finished.\r\n    cachedEventCounts = null;\r\n  });\r\n  return cachedEventCounts ?? new Map();\r\n}\r\n/**\r\n * Implementation of the EventCounts Web Performance API\r\n * corresponding to the standard in\r\n * https://www.w3.org/TR/event-timing/#eventcounts\r\n */\r\nexport default class EventCounts {\r\n  // flowlint unsafe-getters-setters:off\r\n  get size(): number {\r\n    return getCachedEventCounts().size;\r\n  }\r\n\r\n  entries(): Iterator<[string, number]> {\r\n    return getCachedEventCounts().entries();\r\n  }\r\n\r\n  forEach(callback: EventCountsForEachCallbackType): void {\r\n    return getCachedEventCounts().forEach(callback);\r\n  }\r\n\r\n  get(key: string): ?number {\r\n    return getCachedEventCounts().get(key);\r\n  }\r\n\r\n  has(key: string): boolean {\r\n    return getCachedEventCounts().has(key);\r\n  }\r\n\r\n  keys(): Iterator<string> {\r\n    return getCachedEventCounts().keys();\r\n  }\r\n\r\n  values(): Iterator<number> {\r\n    return getCachedEventCounts().values();\r\n  }\r\n}\r\n"],"mappings":";;AAUA,OAAOA,yBAAyB;AAChC,SAAQC,+BAA+B;AAQvC,IAAIC,iBAAuC;AAE3C,SAASC,oBAAoBA,CAAA,EAAwB;EAAA,IAAAC,kBAAA;EACnD,IAAIF,iBAAiB,EAAE;IACrB,OAAOA,iBAAiB;EAC1B;EACA,IAAI,CAACF,yBAAyB,EAAE;IAC9BC,+BAA+B,CAAC,CAAC;IACjC,OAAO,IAAII,GAAG,CAAC,CAAC;EAClB;EAEAH,iBAAiB,GAAG,IAAIG,GAAG,CACzBL,yBAAyB,CAACM,cAAc,CAAC,CAC3C,CAAC;EAEDC,MAAM,CAACC,cAAc,CAAC,YAAM;IAK1BN,iBAAiB,GAAG,IAAI;EAC1B,CAAC,CAAC;EACF,QAAAE,kBAAA,GAAOF,iBAAiB,YAAAE,kBAAA,GAAI,IAAIC,GAAG,CAAC,CAAC;AACvC;AAAC,IAMoBI,WAAW;EAAA,SAAAA,YAAA;IAAAC,eAAA,OAAAD,WAAA;EAAA;EAAAE,YAAA,CAAAF,WAAA;IAAAG,GAAA;IAAAC,GAAA,EAE9B,SAAAA,IAAA,EAAmB;MACjB,OAAOV,oBAAoB,CAAC,CAAC,CAACW,IAAI;IACpC;EAAC;IAAAF,GAAA;IAAAG,KAAA,EAED,SAAAC,QAAA,EAAsC;MACpC,OAAOb,oBAAoB,CAAC,CAAC,CAACa,OAAO,CAAC,CAAC;IACzC;EAAC;IAAAJ,GAAA;IAAAG,KAAA,EAED,SAAAE,QAAQC,QAAwC,EAAQ;MACtD,OAAOf,oBAAoB,CAAC,CAAC,CAACc,OAAO,CAACC,QAAQ,CAAC;IACjD;EAAC;IAAAN,GAAA;IAAAG,KAAA,EAED,SAAAF,IAAID,GAAW,EAAW;MACxB,OAAOT,oBAAoB,CAAC,CAAC,CAACU,GAAG,CAACD,GAAG,CAAC;IACxC;EAAC;IAAAA,GAAA;IAAAG,KAAA,EAED,SAAAI,IAAIP,GAAW,EAAW;MACxB,OAAOT,oBAAoB,CAAC,CAAC,CAACgB,GAAG,CAACP,GAAG,CAAC;IACxC;EAAC;IAAAA,GAAA;IAAAG,KAAA,EAED,SAAAK,KAAA,EAAyB;MACvB,OAAOjB,oBAAoB,CAAC,CAAC,CAACiB,IAAI,CAAC,CAAC;IACtC;EAAC;IAAAR,GAAA;IAAAG,KAAA,EAED,SAAAM,OAAA,EAA2B;MACzB,OAAOlB,oBAAoB,CAAC,CAAC,CAACkB,MAAM,CAAC,CAAC;IACxC;EAAC;EAAA,OAAAZ,WAAA;AAAA;AAAA,SA5BkBA,WAAW,IAAAa,OAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}