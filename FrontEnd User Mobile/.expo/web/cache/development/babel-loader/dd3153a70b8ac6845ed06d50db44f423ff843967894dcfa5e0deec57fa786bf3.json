{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n'use strict';\nimport parseErrorStack from \"../../Core/Devtools/parseErrorStack\";\nimport NativeLogBox from \"../../NativeModules/specs/NativeLogBox\";\nimport LogBoxLog from \"./LogBoxLog\";\nimport { parseLogBoxException } from \"./parseLogBoxLog\";\nimport * as React from 'react';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar observers = new Set();\nvar ignorePatterns = new Set();\nvar appInfo = null;\nvar logs = new Set();\nvar updateTimeout = null;\nvar _isDisabled = false;\nvar _selectedIndex = -1;\nvar warningFilter = function warningFilter(format) {\n  return {\n    finalFormat: format,\n    forceDialogImmediately: false,\n    suppressDialog_LEGACY: true,\n    suppressCompletely: false,\n    monitorEvent: 'unknown',\n    monitorListVersion: 0,\n    monitorSampleRate: 1\n  };\n};\nvar LOGBOX_ERROR_MESSAGE = 'An error was thrown when attempting to render log messages via LogBox.';\nfunction getNextState() {\n  return {\n    logs: logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex\n  };\n}\nexport function reportLogBoxError(error, componentStack) {\n  var ExceptionsManager = require(\"../../Core/ExceptionsManager\");\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n  ExceptionsManager.handleException(error, true);\n}\nexport function isLogBoxErrorMessage(message) {\n  return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);\n}\nexport function isMessageIgnored(message) {\n  for (var pattern of ignorePatterns) {\n    if (pattern instanceof RegExp && pattern.test(message) || typeof pattern === 'string' && message.includes(pattern)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction handleUpdate() {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediate(function () {\n      updateTimeout = null;\n      var nextState = getNextState();\n      observers.forEach(function (_ref) {\n        var observer = _ref.observer;\n        return observer(nextState);\n      });\n    });\n  }\n}\nfunction appendNewLog(newLog) {\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n  var lastLog = Array.from(logs).pop();\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n  if (newLog.level === 'fatal') {\n    var OPTIMISTIC_WAIT_TIME = 1000;\n    var _addPendingLog = function addPendingLog() {\n      logs.add(newLog);\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n      _addPendingLog = null;\n    };\n    var optimisticTimeout = setTimeout(function () {\n      if (_addPendingLog) {\n        _addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n    newLog.symbolicate(function (status) {\n      if (_addPendingLog && status !== 'PENDING') {\n        _addPendingLog();\n        clearTimeout(optimisticTimeout);\n      } else if (status !== 'PENDING') {\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === 'syntax') {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\nexport function addLog(log) {\n  var errorForStackTrace = new Error();\n  setImmediate(function () {\n    try {\n      var stack = parseErrorStack(errorForStackTrace == null ? void 0 : errorForStackTrace.stack);\n      appendNewLog(new LogBoxLog({\n        level: log.level,\n        message: log.message,\n        isComponentError: false,\n        stack: stack,\n        category: log.category,\n        componentStack: log.componentStack\n      }));\n    } catch (error) {\n      reportLogBoxError(error);\n    }\n  });\n}\nexport function addException(error) {\n  setImmediate(function () {\n    try {\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\n    } catch (loggingError) {\n      reportLogBoxError(loggingError);\n    }\n  });\n}\nexport function symbolicateLogNow(log) {\n  log.symbolicate(function () {\n    handleUpdate();\n  });\n}\nexport function retrySymbolicateLogNow(log) {\n  log.retrySymbolicate(function () {\n    handleUpdate();\n  });\n}\nexport function symbolicateLogLazy(log) {\n  log.symbolicate();\n}\nexport function clear() {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\nexport function setSelectedLog(proposedNewIndex) {\n  var oldIndex = _selectedIndex;\n  var newIndex = proposedNewIndex;\n  var logArray = Array.from(logs);\n  var index = logArray.length - 1;\n  while (index >= 0) {\n    if (logArray[index].level === 'syntax') {\n      newIndex = index;\n      break;\n    }\n    index -= 1;\n  }\n  _selectedIndex = newIndex;\n  handleUpdate();\n  if (NativeLogBox) {\n    setTimeout(function () {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox.hide();\n      }\n    }, 0);\n  }\n}\nexport function clearWarnings() {\n  var newLogs = Array.from(logs).filter(function (log) {\n    return log.level !== 'warn';\n  });\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\nexport function clearErrors() {\n  var newLogs = Array.from(logs).filter(function (log) {\n    return log.level !== 'error' && log.level !== 'fatal';\n  });\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\nexport function dismiss(log) {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\nexport function setWarningFilter(filter) {\n  warningFilter = filter;\n}\nexport function setAppInfo(info) {\n  appInfo = info;\n}\nexport function getAppInfo() {\n  return appInfo != null ? appInfo() : null;\n}\nexport function checkWarningFilter(format) {\n  return warningFilter(format);\n}\nexport function getIgnorePatterns() {\n  return Array.from(ignorePatterns);\n}\nexport function addIgnorePatterns(patterns) {\n  var existingSize = ignorePatterns.size;\n  patterns.forEach(function (pattern) {\n    if (pattern instanceof RegExp) {\n      for (var existingPattern of ignorePatterns) {\n        if (existingPattern instanceof RegExp && existingPattern.toString() === pattern.toString()) {\n          return;\n        }\n      }\n      ignorePatterns.add(pattern);\n    }\n    ignorePatterns.add(pattern);\n  });\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n  logs = new Set(Array.from(logs).filter(function (log) {\n    return !isMessageIgnored(log.message.content);\n  }));\n  handleUpdate();\n}\nexport function setDisabled(value) {\n  if (value === _isDisabled) {\n    return;\n  }\n  _isDisabled = value;\n  handleUpdate();\n}\nexport function isDisabled() {\n  return _isDisabled;\n}\nexport function observe(observer) {\n  var subscription = {\n    observer: observer\n  };\n  observers.add(subscription);\n  observer(getNextState());\n  return {\n    unsubscribe: function unsubscribe() {\n      observers.delete(subscription);\n    }\n  };\n}\nexport function withSubscription(WrappedComponent) {\n  var LogBoxStateSubscription = function (_React$Component) {\n    _inherits(LogBoxStateSubscription, _React$Component);\n    var _super = _createSuper(LogBoxStateSubscription);\n    function LogBoxStateSubscription() {\n      var _this;\n      _classCallCheck(this, LogBoxStateSubscription);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _super.call.apply(_super, [this].concat(args));\n      _this.state = {\n        logs: new Set(),\n        isDisabled: false,\n        hasError: false,\n        selectedLogIndex: -1\n      };\n      _this._handleDismiss = function () {\n        var _this$state = _this.state,\n          selectedLogIndex = _this$state.selectedLogIndex,\n          stateLogs = _this$state.logs;\n        var logsArray = Array.from(stateLogs);\n        if (selectedLogIndex != null) {\n          if (logsArray.length - 1 <= 0) {\n            setSelectedLog(-1);\n          } else if (selectedLogIndex >= logsArray.length - 1) {\n            setSelectedLog(selectedLogIndex - 1);\n          }\n          dismiss(logsArray[selectedLogIndex]);\n        }\n      };\n      _this._handleMinimize = function () {\n        setSelectedLog(-1);\n      };\n      _this._handleSetSelectedLog = function (index) {\n        setSelectedLog(index);\n      };\n      return _this;\n    }\n    _createClass(LogBoxStateSubscription, [{\n      key: \"componentDidCatch\",\n      value: function componentDidCatch(err, errorInfo) {\n        reportLogBoxError(err, errorInfo.componentStack);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        if (this.state.hasError) {\n          return null;\n        }\n        return _jsx(WrappedComponent, {\n          logs: Array.from(this.state.logs),\n          isDisabled: this.state.isDisabled,\n          selectedLogIndex: this.state.selectedLogIndex\n        });\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this2 = this;\n        this._subscription = observe(function (data) {\n          _this2.setState(data);\n        });\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        if (this._subscription != null) {\n          this._subscription.unsubscribe();\n        }\n      }\n    }], [{\n      key: \"getDerivedStateFromError\",\n      value: function getDerivedStateFromError() {\n        return {\n          hasError: true\n        };\n      }\n    }]);\n    return LogBoxStateSubscription;\n  }(React.Component);\n  return LogBoxStateSubscription;\n}","map":{"version":3,"names":["parseErrorStack","NativeLogBox","LogBoxLog","parseLogBoxException","React","jsx","_jsx","observers","Set","ignorePatterns","appInfo","logs","updateTimeout","_isDisabled","_selectedIndex","warningFilter","format","finalFormat","forceDialogImmediately","suppressDialog_LEGACY","suppressCompletely","monitorEvent","monitorListVersion","monitorSampleRate","LOGBOX_ERROR_MESSAGE","getNextState","isDisabled","selectedLogIndex","reportLogBoxError","error","componentStack","ExceptionsManager","require","message","handleException","isLogBoxErrorMessage","includes","isMessageIgnored","pattern","RegExp","test","handleUpdate","setImmediate","nextState","forEach","_ref","observer","appendNewLog","newLog","content","lastLog","Array","from","pop","category","incrementCount","level","OPTIMISTIC_WAIT_TIME","addPendingLog","add","setSelectedLog","size","optimisticTimeout","setTimeout","symbolicate","status","clearTimeout","addLog","log","errorForStackTrace","Error","stack","isComponentError","addException","loggingError","symbolicateLogNow","retrySymbolicateLogNow","retrySymbolicate","symbolicateLogLazy","clear","proposedNewIndex","oldIndex","newIndex","logArray","index","length","show","hide","clearWarnings","newLogs","filter","clearErrors","dismiss","has","delete","setWarningFilter","setAppInfo","info","getAppInfo","checkWarningFilter","getIgnorePatterns","addIgnorePatterns","patterns","existingSize","existingPattern","toString","setDisabled","value","observe","subscription","unsubscribe","withSubscription","WrappedComponent","LogBoxStateSubscription","_React$Component","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","args","_key","call","apply","concat","state","hasError","_handleDismiss","_this$state","stateLogs","logsArray","_handleMinimize","_handleSetSelectedLog","_createClass","key","componentDidCatch","err","errorInfo","render","componentDidMount","_this2","_subscription","data","setState","componentWillUnmount","getDerivedStateFromError","Component"],"sources":["D:/Users/julian/GIT/CoffeeLoyalty/FrontEnd User Mobile/node_modules/react-native/Libraries/LogBox/Data/LogBoxData.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict\r\n * @format\r\n */\r\n\r\n('use strict');\r\n\r\nimport type {ExtendedError} from '../../Core/ExtendedError';\r\nimport type {LogLevel} from './LogBoxLog';\r\nimport type {\r\n  Category,\r\n  ComponentStack,\r\n  ExtendedExceptionData,\r\n  Message,\r\n} from './parseLogBoxLog';\r\n\r\nimport parseErrorStack from '../../Core/Devtools/parseErrorStack';\r\nimport NativeLogBox from '../../NativeModules/specs/NativeLogBox';\r\nimport LogBoxLog from './LogBoxLog';\r\nimport {parseLogBoxException} from './parseLogBoxLog';\r\nimport * as React from 'react';\r\nexport type LogBoxLogs = Set<LogBoxLog>;\r\nexport type LogData = $ReadOnly<{|\r\n  level: LogLevel,\r\n  message: Message,\r\n  category: Category,\r\n  componentStack: ComponentStack,\r\n|}>;\r\n\r\nexport type Observer = (\r\n  $ReadOnly<{|\r\n    logs: LogBoxLogs,\r\n    isDisabled: boolean,\r\n    selectedLogIndex: number,\r\n  |}>,\r\n) => void;\r\n\r\nexport type IgnorePattern = string | RegExp;\r\n\r\nexport type Subscription = $ReadOnly<{|\r\n  unsubscribe: () => void,\r\n|}>;\r\n\r\nexport type WarningInfo = {|\r\n  finalFormat: string,\r\n  forceDialogImmediately: boolean,\r\n  suppressDialog_LEGACY: boolean,\r\n  suppressCompletely: boolean,\r\n  monitorEvent: string | null,\r\n  monitorListVersion: number,\r\n  monitorSampleRate: number,\r\n|};\r\n\r\nexport type WarningFilter = (format: string) => WarningInfo;\r\n\r\ntype AppInfo = $ReadOnly<{|\r\n  appVersion: string,\r\n  engine: string,\r\n  onPress?: ?() => void,\r\n|}>;\r\n\r\nconst observers: Set<{observer: Observer, ...}> = new Set();\r\nconst ignorePatterns: Set<IgnorePattern> = new Set();\r\nlet appInfo: ?() => AppInfo = null;\r\nlet logs: LogBoxLogs = new Set();\r\nlet updateTimeout: $FlowFixMe | null = null;\r\nlet _isDisabled = false;\r\nlet _selectedIndex = -1;\r\n\r\nlet warningFilter: WarningFilter = function (format) {\r\n  return {\r\n    finalFormat: format,\r\n    forceDialogImmediately: false,\r\n    suppressDialog_LEGACY: true,\r\n    suppressCompletely: false,\r\n    monitorEvent: 'unknown',\r\n    monitorListVersion: 0,\r\n    monitorSampleRate: 1,\r\n  };\r\n};\r\n\r\nconst LOGBOX_ERROR_MESSAGE =\r\n  'An error was thrown when attempting to render log messages via LogBox.';\r\n\r\nfunction getNextState() {\r\n  return {\r\n    logs,\r\n    isDisabled: _isDisabled,\r\n    selectedLogIndex: _selectedIndex,\r\n  };\r\n}\r\n\r\nexport function reportLogBoxError(\r\n  error: ExtendedError,\r\n  componentStack?: string,\r\n): void {\r\n  const ExceptionsManager = require('../../Core/ExceptionsManager');\r\n\r\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\r\n  if (componentStack != null) {\r\n    error.componentStack = componentStack;\r\n  }\r\n  ExceptionsManager.handleException(error, /* isFatal */ true);\r\n}\r\n\r\nexport function isLogBoxErrorMessage(message: string): boolean {\r\n  return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);\r\n}\r\n\r\nexport function isMessageIgnored(message: string): boolean {\r\n  for (const pattern of ignorePatterns) {\r\n    if (\r\n      (pattern instanceof RegExp && pattern.test(message)) ||\r\n      (typeof pattern === 'string' && message.includes(pattern))\r\n    ) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction handleUpdate(): void {\r\n  if (updateTimeout == null) {\r\n    updateTimeout = setImmediate(() => {\r\n      updateTimeout = null;\r\n      const nextState = getNextState();\r\n      observers.forEach(({observer}) => observer(nextState));\r\n    });\r\n  }\r\n}\r\n\r\nfunction appendNewLog(newLog: LogBoxLog) {\r\n  // Don't want store these logs because they trigger a\r\n  // state update when we add them to the store.\r\n  if (isMessageIgnored(newLog.message.content)) {\r\n    return;\r\n  }\r\n\r\n  // If the next log has the same category as the previous one\r\n  // then roll it up into the last log in the list by incrementing\r\n  // the count (similar to how Chrome does it).\r\n  const lastLog = Array.from(logs).pop();\r\n  if (lastLog && lastLog.category === newLog.category) {\r\n    lastLog.incrementCount();\r\n    handleUpdate();\r\n    return;\r\n  }\r\n\r\n  if (newLog.level === 'fatal') {\r\n    // If possible, to avoid jank, we don't want to open the error before\r\n    // it's symbolicated. To do that, we optimistically wait for\r\n    // symbolication for up to a second before adding the log.\r\n    const OPTIMISTIC_WAIT_TIME = 1000;\r\n\r\n    let addPendingLog: ?() => void = () => {\r\n      logs.add(newLog);\r\n      if (_selectedIndex < 0) {\r\n        setSelectedLog(logs.size - 1);\r\n      } else {\r\n        handleUpdate();\r\n      }\r\n      addPendingLog = null;\r\n    };\r\n\r\n    const optimisticTimeout = setTimeout(() => {\r\n      if (addPendingLog) {\r\n        addPendingLog();\r\n      }\r\n    }, OPTIMISTIC_WAIT_TIME);\r\n\r\n    newLog.symbolicate(status => {\r\n      if (addPendingLog && status !== 'PENDING') {\r\n        addPendingLog();\r\n        clearTimeout(optimisticTimeout);\r\n      } else if (status !== 'PENDING') {\r\n        // The log has already been added but we need to trigger a render.\r\n        handleUpdate();\r\n      }\r\n    });\r\n  } else if (newLog.level === 'syntax') {\r\n    logs.add(newLog);\r\n    setSelectedLog(logs.size - 1);\r\n  } else {\r\n    logs.add(newLog);\r\n    handleUpdate();\r\n  }\r\n}\r\n\r\nexport function addLog(log: LogData): void {\r\n  const errorForStackTrace = new Error();\r\n\r\n  // Parsing logs are expensive so we schedule this\r\n  // otherwise spammy logs would pause rendering.\r\n  setImmediate(() => {\r\n    try {\r\n      const stack = parseErrorStack(errorForStackTrace?.stack);\r\n\r\n      appendNewLog(\r\n        new LogBoxLog({\r\n          level: log.level,\r\n          message: log.message,\r\n          isComponentError: false,\r\n          stack,\r\n          category: log.category,\r\n          componentStack: log.componentStack,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      reportLogBoxError(error);\r\n    }\r\n  });\r\n}\r\n\r\nexport function addException(error: ExtendedExceptionData): void {\r\n  // Parsing logs are expensive so we schedule this\r\n  // otherwise spammy logs would pause rendering.\r\n  setImmediate(() => {\r\n    try {\r\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\r\n    } catch (loggingError) {\r\n      reportLogBoxError(loggingError);\r\n    }\r\n  });\r\n}\r\n\r\nexport function symbolicateLogNow(log: LogBoxLog) {\r\n  log.symbolicate(() => {\r\n    handleUpdate();\r\n  });\r\n}\r\n\r\nexport function retrySymbolicateLogNow(log: LogBoxLog) {\r\n  log.retrySymbolicate(() => {\r\n    handleUpdate();\r\n  });\r\n}\r\n\r\nexport function symbolicateLogLazy(log: LogBoxLog) {\r\n  log.symbolicate();\r\n}\r\n\r\nexport function clear(): void {\r\n  if (logs.size > 0) {\r\n    logs = new Set();\r\n    setSelectedLog(-1);\r\n  }\r\n}\r\n\r\nexport function setSelectedLog(proposedNewIndex: number): void {\r\n  const oldIndex = _selectedIndex;\r\n  let newIndex = proposedNewIndex;\r\n\r\n  const logArray = Array.from(logs);\r\n  let index = logArray.length - 1;\r\n  while (index >= 0) {\r\n    // The latest syntax error is selected and displayed before all other logs.\r\n    if (logArray[index].level === 'syntax') {\r\n      newIndex = index;\r\n      break;\r\n    }\r\n    index -= 1;\r\n  }\r\n  _selectedIndex = newIndex;\r\n  handleUpdate();\r\n  if (NativeLogBox) {\r\n    setTimeout(() => {\r\n      if (oldIndex < 0 && newIndex >= 0) {\r\n        NativeLogBox.show();\r\n      } else if (oldIndex >= 0 && newIndex < 0) {\r\n        NativeLogBox.hide();\r\n      }\r\n    }, 0);\r\n  }\r\n}\r\n\r\nexport function clearWarnings(): void {\r\n  const newLogs = Array.from(logs).filter(log => log.level !== 'warn');\r\n  if (newLogs.length !== logs.size) {\r\n    logs = new Set(newLogs);\r\n    setSelectedLog(-1);\r\n    handleUpdate();\r\n  }\r\n}\r\n\r\nexport function clearErrors(): void {\r\n  const newLogs = Array.from(logs).filter(\r\n    log => log.level !== 'error' && log.level !== 'fatal',\r\n  );\r\n  if (newLogs.length !== logs.size) {\r\n    logs = new Set(newLogs);\r\n    setSelectedLog(-1);\r\n  }\r\n}\r\n\r\nexport function dismiss(log: LogBoxLog): void {\r\n  if (logs.has(log)) {\r\n    logs.delete(log);\r\n    handleUpdate();\r\n  }\r\n}\r\n\r\nexport function setWarningFilter(filter: WarningFilter): void {\r\n  warningFilter = filter;\r\n}\r\n\r\nexport function setAppInfo(info: () => AppInfo): void {\r\n  appInfo = info;\r\n}\r\n\r\nexport function getAppInfo(): ?AppInfo {\r\n  return appInfo != null ? appInfo() : null;\r\n}\r\n\r\nexport function checkWarningFilter(format: string): WarningInfo {\r\n  return warningFilter(format);\r\n}\r\n\r\nexport function getIgnorePatterns(): $ReadOnlyArray<IgnorePattern> {\r\n  return Array.from(ignorePatterns);\r\n}\r\n\r\nexport function addIgnorePatterns(\r\n  patterns: $ReadOnlyArray<IgnorePattern>,\r\n): void {\r\n  const existingSize = ignorePatterns.size;\r\n  // The same pattern may be added multiple times, but adding a new pattern\r\n  // can be expensive so let's find only the ones that are new.\r\n  patterns.forEach((pattern: IgnorePattern) => {\r\n    if (pattern instanceof RegExp) {\r\n      for (const existingPattern of ignorePatterns) {\r\n        if (\r\n          existingPattern instanceof RegExp &&\r\n          existingPattern.toString() === pattern.toString()\r\n        ) {\r\n          return;\r\n        }\r\n      }\r\n      ignorePatterns.add(pattern);\r\n    }\r\n    ignorePatterns.add(pattern);\r\n  });\r\n  if (ignorePatterns.size === existingSize) {\r\n    return;\r\n  }\r\n  // We need to recheck all of the existing logs.\r\n  // This allows adding an ignore pattern anywhere in the codebase.\r\n  // Without this, if you ignore a pattern after the a log is created,\r\n  // then we would keep showing the log.\r\n  logs = new Set(\r\n    Array.from(logs).filter(log => !isMessageIgnored(log.message.content)),\r\n  );\r\n  handleUpdate();\r\n}\r\n\r\nexport function setDisabled(value: boolean): void {\r\n  if (value === _isDisabled) {\r\n    return;\r\n  }\r\n  _isDisabled = value;\r\n  handleUpdate();\r\n}\r\n\r\nexport function isDisabled(): boolean {\r\n  return _isDisabled;\r\n}\r\n\r\nexport function observe(observer: Observer): Subscription {\r\n  const subscription = {observer};\r\n  observers.add(subscription);\r\n\r\n  observer(getNextState());\r\n\r\n  return {\r\n    unsubscribe(): void {\r\n      observers.delete(subscription);\r\n    },\r\n  };\r\n}\r\n\r\ntype Props = $ReadOnly<{||}>;\r\ntype State = $ReadOnly<{|\r\n  logs: LogBoxLogs,\r\n  isDisabled: boolean,\r\n  hasError: boolean,\r\n  selectedLogIndex: number,\r\n|}>;\r\n\r\ntype SubscribedComponent = React.AbstractComponent<\r\n  $ReadOnly<{|\r\n    logs: $ReadOnlyArray<LogBoxLog>,\r\n    isDisabled: boolean,\r\n    selectedLogIndex: number,\r\n  |}>,\r\n>;\r\n\r\nexport function withSubscription(\r\n  WrappedComponent: SubscribedComponent,\r\n): React.AbstractComponent<{||}> {\r\n  class LogBoxStateSubscription extends React.Component<Props, State> {\r\n    static getDerivedStateFromError(): {hasError: boolean} {\r\n      return {hasError: true};\r\n    }\r\n\r\n    componentDidCatch(err: Error, errorInfo: {componentStack: string, ...}) {\r\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\r\n       * this parameters */\r\n      reportLogBoxError(err, errorInfo.componentStack);\r\n    }\r\n\r\n    _subscription: ?Subscription;\r\n\r\n    state: State = {\r\n      logs: new Set(),\r\n      isDisabled: false,\r\n      hasError: false,\r\n      selectedLogIndex: -1,\r\n    };\r\n\r\n    render(): React.Node {\r\n      if (this.state.hasError) {\r\n        // This happens when the component failed to render, in which case we delegate to the native redbox.\r\n        // We can't show anyback fallback UI here, because the error may be with <View> or <Text>.\r\n        return null;\r\n      }\r\n\r\n      return (\r\n        <WrappedComponent\r\n          logs={Array.from(this.state.logs)}\r\n          isDisabled={this.state.isDisabled}\r\n          selectedLogIndex={this.state.selectedLogIndex}\r\n        />\r\n      );\r\n    }\r\n\r\n    componentDidMount(): void {\r\n      this._subscription = observe(data => {\r\n        this.setState(data);\r\n      });\r\n    }\r\n\r\n    componentWillUnmount(): void {\r\n      if (this._subscription != null) {\r\n        this._subscription.unsubscribe();\r\n      }\r\n    }\r\n\r\n    _handleDismiss = (): void => {\r\n      // Here we handle the cases when the log is dismissed and it\r\n      // was either the last log, or when the current index\r\n      // is now outside the bounds of the log array.\r\n      const {selectedLogIndex, logs: stateLogs} = this.state;\r\n      const logsArray = Array.from(stateLogs);\r\n      if (selectedLogIndex != null) {\r\n        if (logsArray.length - 1 <= 0) {\r\n          setSelectedLog(-1);\r\n        } else if (selectedLogIndex >= logsArray.length - 1) {\r\n          setSelectedLog(selectedLogIndex - 1);\r\n        }\r\n\r\n        dismiss(logsArray[selectedLogIndex]);\r\n      }\r\n    };\r\n\r\n    _handleMinimize = (): void => {\r\n      setSelectedLog(-1);\r\n    };\r\n\r\n    _handleSetSelectedLog = (index: number): void => {\r\n      setSelectedLog(index);\r\n    };\r\n  }\r\n\r\n  return LogBoxStateSubscription;\r\n}\r\n"],"mappings":";;;;;;;AAUC,YAAY;AAWb,OAAOA,eAAe;AACtB,OAAOC,YAAY;AACnB,OAAOC,SAAS;AAChB,SAAQC,oBAAoB;AAC5B,OAAO,KAAKC,KAAK,MAAM,OAAO;AAAC,SAAAC,GAAA,IAAAC,IAAA;AAyC/B,IAAMC,SAAyC,GAAG,IAAIC,GAAG,CAAC,CAAC;AAC3D,IAAMC,cAAkC,GAAG,IAAID,GAAG,CAAC,CAAC;AACpD,IAAIE,OAAuB,GAAG,IAAI;AAClC,IAAIC,IAAgB,GAAG,IAAIH,GAAG,CAAC,CAAC;AAChC,IAAII,aAAgC,GAAG,IAAI;AAC3C,IAAIC,WAAW,GAAG,KAAK;AACvB,IAAIC,cAAc,GAAG,CAAC,CAAC;AAEvB,IAAIC,aAA4B,GAAG,SAAAA,cAAUC,MAAM,EAAE;EACnD,OAAO;IACLC,WAAW,EAAED,MAAM;IACnBE,sBAAsB,EAAE,KAAK;IAC7BC,qBAAqB,EAAE,IAAI;IAC3BC,kBAAkB,EAAE,KAAK;IACzBC,YAAY,EAAE,SAAS;IACvBC,kBAAkB,EAAE,CAAC;IACrBC,iBAAiB,EAAE;EACrB,CAAC;AACH,CAAC;AAED,IAAMC,oBAAoB,GACxB,wEAAwE;AAE1E,SAASC,YAAYA,CAAA,EAAG;EACtB,OAAO;IACLd,IAAI,EAAJA,IAAI;IACJe,UAAU,EAAEb,WAAW;IACvBc,gBAAgB,EAAEb;EACpB,CAAC;AACH;AAEA,OAAO,SAASc,iBAAiBA,CAC/BC,KAAoB,EACpBC,cAAuB,EACjB;EACN,IAAMC,iBAAiB,GAAGC,OAAO,+BAA+B,CAAC;EAEjEH,KAAK,CAACI,OAAO,GAAI,GAAET,oBAAqB,OAAMK,KAAK,CAACI,OAAQ,EAAC;EAC7D,IAAIH,cAAc,IAAI,IAAI,EAAE;IAC1BD,KAAK,CAACC,cAAc,GAAGA,cAAc;EACvC;EACAC,iBAAiB,CAACG,eAAe,CAACL,KAAK,EAAgB,IAAI,CAAC;AAC9D;AAEA,OAAO,SAASM,oBAAoBA,CAACF,OAAe,EAAW;EAC7D,OAAO,OAAOA,OAAO,KAAK,QAAQ,IAAIA,OAAO,CAACG,QAAQ,CAACZ,oBAAoB,CAAC;AAC9E;AAEA,OAAO,SAASa,gBAAgBA,CAACJ,OAAe,EAAW;EACzD,KAAK,IAAMK,OAAO,IAAI7B,cAAc,EAAE;IACpC,IACG6B,OAAO,YAAYC,MAAM,IAAID,OAAO,CAACE,IAAI,CAACP,OAAO,CAAC,IAClD,OAAOK,OAAO,KAAK,QAAQ,IAAIL,OAAO,CAACG,QAAQ,CAACE,OAAO,CAAE,EAC1D;MACA,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd;AAEA,SAASG,YAAYA,CAAA,EAAS;EAC5B,IAAI7B,aAAa,IAAI,IAAI,EAAE;IACzBA,aAAa,GAAG8B,YAAY,CAAC,YAAM;MACjC9B,aAAa,GAAG,IAAI;MACpB,IAAM+B,SAAS,GAAGlB,YAAY,CAAC,CAAC;MAChClB,SAAS,CAACqC,OAAO,CAAC,UAAAC,IAAA;QAAA,IAAEC,QAAQ,GAAAD,IAAA,CAARC,QAAQ;QAAA,OAAMA,QAAQ,CAACH,SAAS,CAAC;MAAA,EAAC;IACxD,CAAC,CAAC;EACJ;AACF;AAEA,SAASI,YAAYA,CAACC,MAAiB,EAAE;EAGvC,IAAIX,gBAAgB,CAACW,MAAM,CAACf,OAAO,CAACgB,OAAO,CAAC,EAAE;IAC5C;EACF;EAKA,IAAMC,OAAO,GAAGC,KAAK,CAACC,IAAI,CAACzC,IAAI,CAAC,CAAC0C,GAAG,CAAC,CAAC;EACtC,IAAIH,OAAO,IAAIA,OAAO,CAACI,QAAQ,KAAKN,MAAM,CAACM,QAAQ,EAAE;IACnDJ,OAAO,CAACK,cAAc,CAAC,CAAC;IACxBd,YAAY,CAAC,CAAC;IACd;EACF;EAEA,IAAIO,MAAM,CAACQ,KAAK,KAAK,OAAO,EAAE;IAI5B,IAAMC,oBAAoB,GAAG,IAAI;IAEjC,IAAIC,cAA0B,GAAG,SAAAA,cAAA,EAAM;MACrC/C,IAAI,CAACgD,GAAG,CAACX,MAAM,CAAC;MAChB,IAAIlC,cAAc,GAAG,CAAC,EAAE;QACtB8C,cAAc,CAACjD,IAAI,CAACkD,IAAI,GAAG,CAAC,CAAC;MAC/B,CAAC,MAAM;QACLpB,YAAY,CAAC,CAAC;MAChB;MACAiB,cAAa,GAAG,IAAI;IACtB,CAAC;IAED,IAAMI,iBAAiB,GAAGC,UAAU,CAAC,YAAM;MACzC,IAAIL,cAAa,EAAE;QACjBA,cAAa,CAAC,CAAC;MACjB;IACF,CAAC,EAAED,oBAAoB,CAAC;IAExBT,MAAM,CAACgB,WAAW,CAAC,UAAAC,MAAM,EAAI;MAC3B,IAAIP,cAAa,IAAIO,MAAM,KAAK,SAAS,EAAE;QACzCP,cAAa,CAAC,CAAC;QACfQ,YAAY,CAACJ,iBAAiB,CAAC;MACjC,CAAC,MAAM,IAAIG,MAAM,KAAK,SAAS,EAAE;QAE/BxB,YAAY,CAAC,CAAC;MAChB;IACF,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIO,MAAM,CAACQ,KAAK,KAAK,QAAQ,EAAE;IACpC7C,IAAI,CAACgD,GAAG,CAACX,MAAM,CAAC;IAChBY,cAAc,CAACjD,IAAI,CAACkD,IAAI,GAAG,CAAC,CAAC;EAC/B,CAAC,MAAM;IACLlD,IAAI,CAACgD,GAAG,CAACX,MAAM,CAAC;IAChBP,YAAY,CAAC,CAAC;EAChB;AACF;AAEA,OAAO,SAAS0B,MAAMA,CAACC,GAAY,EAAQ;EACzC,IAAMC,kBAAkB,GAAG,IAAIC,KAAK,CAAC,CAAC;EAItC5B,YAAY,CAAC,YAAM;IACjB,IAAI;MACF,IAAM6B,KAAK,GAAGvE,eAAe,CAACqE,kBAAkB,oBAAlBA,kBAAkB,CAAEE,KAAK,CAAC;MAExDxB,YAAY,CACV,IAAI7C,SAAS,CAAC;QACZsD,KAAK,EAAEY,GAAG,CAACZ,KAAK;QAChBvB,OAAO,EAAEmC,GAAG,CAACnC,OAAO;QACpBuC,gBAAgB,EAAE,KAAK;QACvBD,KAAK,EAALA,KAAK;QACLjB,QAAQ,EAAEc,GAAG,CAACd,QAAQ;QACtBxB,cAAc,EAAEsC,GAAG,CAACtC;MACtB,CAAC,CACH,CAAC;IACH,CAAC,CAAC,OAAOD,KAAK,EAAE;MACdD,iBAAiB,CAACC,KAAK,CAAC;IAC1B;EACF,CAAC,CAAC;AACJ;AAEA,OAAO,SAAS4C,YAAYA,CAAC5C,KAA4B,EAAQ;EAG/Da,YAAY,CAAC,YAAM;IACjB,IAAI;MACFK,YAAY,CAAC,IAAI7C,SAAS,CAACC,oBAAoB,CAAC0B,KAAK,CAAC,CAAC,CAAC;IAC1D,CAAC,CAAC,OAAO6C,YAAY,EAAE;MACrB9C,iBAAiB,CAAC8C,YAAY,CAAC;IACjC;EACF,CAAC,CAAC;AACJ;AAEA,OAAO,SAASC,iBAAiBA,CAACP,GAAc,EAAE;EAChDA,GAAG,CAACJ,WAAW,CAAC,YAAM;IACpBvB,YAAY,CAAC,CAAC;EAChB,CAAC,CAAC;AACJ;AAEA,OAAO,SAASmC,sBAAsBA,CAACR,GAAc,EAAE;EACrDA,GAAG,CAACS,gBAAgB,CAAC,YAAM;IACzBpC,YAAY,CAAC,CAAC;EAChB,CAAC,CAAC;AACJ;AAEA,OAAO,SAASqC,kBAAkBA,CAACV,GAAc,EAAE;EACjDA,GAAG,CAACJ,WAAW,CAAC,CAAC;AACnB;AAEA,OAAO,SAASe,KAAKA,CAAA,EAAS;EAC5B,IAAIpE,IAAI,CAACkD,IAAI,GAAG,CAAC,EAAE;IACjBlD,IAAI,GAAG,IAAIH,GAAG,CAAC,CAAC;IAChBoD,cAAc,CAAC,CAAC,CAAC,CAAC;EACpB;AACF;AAEA,OAAO,SAASA,cAAcA,CAACoB,gBAAwB,EAAQ;EAC7D,IAAMC,QAAQ,GAAGnE,cAAc;EAC/B,IAAIoE,QAAQ,GAAGF,gBAAgB;EAE/B,IAAMG,QAAQ,GAAGhC,KAAK,CAACC,IAAI,CAACzC,IAAI,CAAC;EACjC,IAAIyE,KAAK,GAAGD,QAAQ,CAACE,MAAM,GAAG,CAAC;EAC/B,OAAOD,KAAK,IAAI,CAAC,EAAE;IAEjB,IAAID,QAAQ,CAACC,KAAK,CAAC,CAAC5B,KAAK,KAAK,QAAQ,EAAE;MACtC0B,QAAQ,GAAGE,KAAK;MAChB;IACF;IACAA,KAAK,IAAI,CAAC;EACZ;EACAtE,cAAc,GAAGoE,QAAQ;EACzBzC,YAAY,CAAC,CAAC;EACd,IAAIxC,YAAY,EAAE;IAChB8D,UAAU,CAAC,YAAM;MACf,IAAIkB,QAAQ,GAAG,CAAC,IAAIC,QAAQ,IAAI,CAAC,EAAE;QACjCjF,YAAY,CAACqF,IAAI,CAAC,CAAC;MACrB,CAAC,MAAM,IAAIL,QAAQ,IAAI,CAAC,IAAIC,QAAQ,GAAG,CAAC,EAAE;QACxCjF,YAAY,CAACsF,IAAI,CAAC,CAAC;MACrB;IACF,CAAC,EAAE,CAAC,CAAC;EACP;AACF;AAEA,OAAO,SAASC,aAAaA,CAAA,EAAS;EACpC,IAAMC,OAAO,GAAGtC,KAAK,CAACC,IAAI,CAACzC,IAAI,CAAC,CAAC+E,MAAM,CAAC,UAAAtB,GAAG;IAAA,OAAIA,GAAG,CAACZ,KAAK,KAAK,MAAM;EAAA,EAAC;EACpE,IAAIiC,OAAO,CAACJ,MAAM,KAAK1E,IAAI,CAACkD,IAAI,EAAE;IAChClD,IAAI,GAAG,IAAIH,GAAG,CAACiF,OAAO,CAAC;IACvB7B,cAAc,CAAC,CAAC,CAAC,CAAC;IAClBnB,YAAY,CAAC,CAAC;EAChB;AACF;AAEA,OAAO,SAASkD,WAAWA,CAAA,EAAS;EAClC,IAAMF,OAAO,GAAGtC,KAAK,CAACC,IAAI,CAACzC,IAAI,CAAC,CAAC+E,MAAM,CACrC,UAAAtB,GAAG;IAAA,OAAIA,GAAG,CAACZ,KAAK,KAAK,OAAO,IAAIY,GAAG,CAACZ,KAAK,KAAK,OAAO;EAAA,CACvD,CAAC;EACD,IAAIiC,OAAO,CAACJ,MAAM,KAAK1E,IAAI,CAACkD,IAAI,EAAE;IAChClD,IAAI,GAAG,IAAIH,GAAG,CAACiF,OAAO,CAAC;IACvB7B,cAAc,CAAC,CAAC,CAAC,CAAC;EACpB;AACF;AAEA,OAAO,SAASgC,OAAOA,CAACxB,GAAc,EAAQ;EAC5C,IAAIzD,IAAI,CAACkF,GAAG,CAACzB,GAAG,CAAC,EAAE;IACjBzD,IAAI,CAACmF,MAAM,CAAC1B,GAAG,CAAC;IAChB3B,YAAY,CAAC,CAAC;EAChB;AACF;AAEA,OAAO,SAASsD,gBAAgBA,CAACL,MAAqB,EAAQ;EAC5D3E,aAAa,GAAG2E,MAAM;AACxB;AAEA,OAAO,SAASM,UAAUA,CAACC,IAAmB,EAAQ;EACpDvF,OAAO,GAAGuF,IAAI;AAChB;AAEA,OAAO,SAASC,UAAUA,CAAA,EAAa;EACrC,OAAOxF,OAAO,IAAI,IAAI,GAAGA,OAAO,CAAC,CAAC,GAAG,IAAI;AAC3C;AAEA,OAAO,SAASyF,kBAAkBA,CAACnF,MAAc,EAAe;EAC9D,OAAOD,aAAa,CAACC,MAAM,CAAC;AAC9B;AAEA,OAAO,SAASoF,iBAAiBA,CAAA,EAAkC;EACjE,OAAOjD,KAAK,CAACC,IAAI,CAAC3C,cAAc,CAAC;AACnC;AAEA,OAAO,SAAS4F,iBAAiBA,CAC/BC,QAAuC,EACjC;EACN,IAAMC,YAAY,GAAG9F,cAAc,CAACoD,IAAI;EAGxCyC,QAAQ,CAAC1D,OAAO,CAAC,UAACN,OAAsB,EAAK;IAC3C,IAAIA,OAAO,YAAYC,MAAM,EAAE;MAC7B,KAAK,IAAMiE,eAAe,IAAI/F,cAAc,EAAE;QAC5C,IACE+F,eAAe,YAAYjE,MAAM,IACjCiE,eAAe,CAACC,QAAQ,CAAC,CAAC,KAAKnE,OAAO,CAACmE,QAAQ,CAAC,CAAC,EACjD;UACA;QACF;MACF;MACAhG,cAAc,CAACkD,GAAG,CAACrB,OAAO,CAAC;IAC7B;IACA7B,cAAc,CAACkD,GAAG,CAACrB,OAAO,CAAC;EAC7B,CAAC,CAAC;EACF,IAAI7B,cAAc,CAACoD,IAAI,KAAK0C,YAAY,EAAE;IACxC;EACF;EAKA5F,IAAI,GAAG,IAAIH,GAAG,CACZ2C,KAAK,CAACC,IAAI,CAACzC,IAAI,CAAC,CAAC+E,MAAM,CAAC,UAAAtB,GAAG;IAAA,OAAI,CAAC/B,gBAAgB,CAAC+B,GAAG,CAACnC,OAAO,CAACgB,OAAO,CAAC;EAAA,EACvE,CAAC;EACDR,YAAY,CAAC,CAAC;AAChB;AAEA,OAAO,SAASiE,WAAWA,CAACC,KAAc,EAAQ;EAChD,IAAIA,KAAK,KAAK9F,WAAW,EAAE;IACzB;EACF;EACAA,WAAW,GAAG8F,KAAK;EACnBlE,YAAY,CAAC,CAAC;AAChB;AAEA,OAAO,SAASf,UAAUA,CAAA,EAAY;EACpC,OAAOb,WAAW;AACpB;AAEA,OAAO,SAAS+F,OAAOA,CAAC9D,QAAkB,EAAgB;EACxD,IAAM+D,YAAY,GAAG;IAAC/D,QAAQ,EAARA;EAAQ,CAAC;EAC/BvC,SAAS,CAACoD,GAAG,CAACkD,YAAY,CAAC;EAE3B/D,QAAQ,CAACrB,YAAY,CAAC,CAAC,CAAC;EAExB,OAAO;IACLqF,WAAW,WAAAA,YAAA,EAAS;MAClBvG,SAAS,CAACuF,MAAM,CAACe,YAAY,CAAC;IAChC;EACF,CAAC;AACH;AAkBA,OAAO,SAASE,gBAAgBA,CAC9BC,gBAAqC,EACN;EAAA,IACzBC,uBAAuB,aAAAC,gBAAA;IAAAC,SAAA,CAAAF,uBAAA,EAAAC,gBAAA;IAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,uBAAA;IAAA,SAAAA,wBAAA;MAAA,IAAAK,KAAA;MAAAC,eAAA,OAAAN,uBAAA;MAAA,SAAAO,IAAA,GAAAC,SAAA,CAAApC,MAAA,EAAAqC,IAAA,OAAAvE,KAAA,CAAAqE,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;QAAAD,IAAA,CAAAC,IAAA,IAAAF,SAAA,CAAAE,IAAA;MAAA;MAAAL,KAAA,GAAAF,MAAA,CAAAQ,IAAA,CAAAC,KAAA,CAAAT,MAAA,SAAAU,MAAA,CAAAJ,IAAA;MAAAJ,KAAA,CAa3BS,KAAK,GAAU;QACbpH,IAAI,EAAE,IAAIH,GAAG,CAAC,CAAC;QACfkB,UAAU,EAAE,KAAK;QACjBsG,QAAQ,EAAE,KAAK;QACfrG,gBAAgB,EAAE,CAAC;MACrB,CAAC;MAAA2F,KAAA,CA8BDW,cAAc,GAAG,YAAY;QAI3B,IAAAC,WAAA,GAA4CZ,KAAA,CAAKS,KAAK;UAA/CpG,gBAAgB,GAAAuG,WAAA,CAAhBvG,gBAAgB;UAAQwG,SAAS,GAAAD,WAAA,CAAfvH,IAAI;QAC7B,IAAMyH,SAAS,GAAGjF,KAAK,CAACC,IAAI,CAAC+E,SAAS,CAAC;QACvC,IAAIxG,gBAAgB,IAAI,IAAI,EAAE;UAC5B,IAAIyG,SAAS,CAAC/C,MAAM,GAAG,CAAC,IAAI,CAAC,EAAE;YAC7BzB,cAAc,CAAC,CAAC,CAAC,CAAC;UACpB,CAAC,MAAM,IAAIjC,gBAAgB,IAAIyG,SAAS,CAAC/C,MAAM,GAAG,CAAC,EAAE;YACnDzB,cAAc,CAACjC,gBAAgB,GAAG,CAAC,CAAC;UACtC;UAEAiE,OAAO,CAACwC,SAAS,CAACzG,gBAAgB,CAAC,CAAC;QACtC;MACF,CAAC;MAAA2F,KAAA,CAEDe,eAAe,GAAG,YAAY;QAC5BzE,cAAc,CAAC,CAAC,CAAC,CAAC;MACpB,CAAC;MAAA0D,KAAA,CAEDgB,qBAAqB,GAAG,UAAClD,KAAa,EAAW;QAC/CxB,cAAc,CAACwB,KAAK,CAAC;MACvB,CAAC;MAAA,OAAAkC,KAAA;IAAA;IAAAiB,YAAA,CAAAtB,uBAAA;MAAAuB,GAAA;MAAA7B,KAAA,EAlED,SAAA8B,kBAAkBC,GAAU,EAAEC,SAAwC,EAAE;QAGtE/G,iBAAiB,CAAC8G,GAAG,EAAEC,SAAS,CAAC7G,cAAc,CAAC;MAClD;IAAC;MAAA0G,GAAA;MAAA7B,KAAA,EAWD,SAAAiC,OAAA,EAAqB;QACnB,IAAI,IAAI,CAACb,KAAK,CAACC,QAAQ,EAAE;UAGvB,OAAO,IAAI;QACb;QAEA,OACE1H,IAAA,CAAC0G,gBAAgB;UACfrG,IAAI,EAAEwC,KAAK,CAACC,IAAI,CAAC,IAAI,CAAC2E,KAAK,CAACpH,IAAI,CAAE;UAClCe,UAAU,EAAE,IAAI,CAACqG,KAAK,CAACrG,UAAW;UAClCC,gBAAgB,EAAE,IAAI,CAACoG,KAAK,CAACpG;QAAiB,CAC/C,CAAC;MAEN;IAAC;MAAA6G,GAAA;MAAA7B,KAAA,EAED,SAAAkC,kBAAA,EAA0B;QAAA,IAAAC,MAAA;QACxB,IAAI,CAACC,aAAa,GAAGnC,OAAO,CAAC,UAAAoC,IAAI,EAAI;UACnCF,MAAI,CAACG,QAAQ,CAACD,IAAI,CAAC;QACrB,CAAC,CAAC;MACJ;IAAC;MAAAR,GAAA;MAAA7B,KAAA,EAED,SAAAuC,qBAAA,EAA6B;QAC3B,IAAI,IAAI,CAACH,aAAa,IAAI,IAAI,EAAE;UAC9B,IAAI,CAACA,aAAa,CAACjC,WAAW,CAAC,CAAC;QAClC;MACF;IAAC;MAAA0B,GAAA;MAAA7B,KAAA,EA7CD,SAAAwC,yBAAA,EAAuD;QACrD,OAAO;UAACnB,QAAQ,EAAE;QAAI,CAAC;MACzB;IAAC;IAAA,OAAAf,uBAAA;EAAA,EAHmC7G,KAAK,CAACgJ,SAAS;EA0ErD,OAAOnC,uBAAuB;AAChC"},"metadata":{},"sourceType":"module","externalDependencies":[]}