{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport warnOnce from \"../Utilities/warnOnce\";\nimport NativePerformanceObserver from \"./NativePerformanceObserver\";\nimport { PerformanceEntry } from \"./PerformanceEntry\";\nimport { performanceEntryTypeToRaw, rawToPerformanceEntry } from \"./RawPerformanceEntry\";\nexport var PerformanceObserverEntryList = function () {\n  function PerformanceObserverEntryList(entries) {\n    _classCallCheck(this, PerformanceObserverEntryList);\n    this._entries = entries;\n  }\n  _createClass(PerformanceObserverEntryList, [{\n    key: \"getEntries\",\n    value: function getEntries() {\n      return this._entries;\n    }\n  }, {\n    key: \"getEntriesByType\",\n    value: function getEntriesByType(type) {\n      return this._entries.filter(function (entry) {\n        return entry.entryType === type;\n      });\n    }\n  }, {\n    key: \"getEntriesByName\",\n    value: function getEntriesByName(name, type) {\n      if (type === undefined) {\n        return this._entries.filter(function (entry) {\n          return entry.name === name;\n        });\n      } else {\n        return this._entries.filter(function (entry) {\n          return entry.name === name && entry.entryType === type;\n        });\n      }\n    }\n  }]);\n  return PerformanceObserverEntryList;\n}();\nvar observerCountPerEntryType = new Map();\nvar registeredObservers = new Map();\nvar isOnPerformanceEntryCallbackSet = false;\nvar onPerformanceEntry = function onPerformanceEntry() {\n  var _entryResult$entries;\n  if (!NativePerformanceObserver) {\n    return;\n  }\n  var entryResult = NativePerformanceObserver.popPendingEntries();\n  var rawEntries = (_entryResult$entries = entryResult == null ? void 0 : entryResult.entries) != null ? _entryResult$entries : [];\n  var droppedEntriesCount = entryResult == null ? void 0 : entryResult.droppedEntriesCount;\n  if (rawEntries.length === 0) {\n    return;\n  }\n  var entries = rawEntries.map(rawToPerformanceEntry);\n  var _loop = function _loop(observerConfig) {\n    var entriesForObserver = entries.filter(function (entry) {\n      if (!observerConfig.entryTypes.has(entry.entryType)) {\n        return false;\n      }\n      var durationThreshold = observerConfig.entryTypes.get(entry.entryType);\n      return entry.duration >= (durationThreshold != null ? durationThreshold : 0);\n    });\n    observerConfig.callback(new PerformanceObserverEntryList(entriesForObserver), _observer, droppedEntriesCount);\n  };\n  for (var _ref of registeredObservers.entries()) {\n    var _ref2 = _slicedToArray(_ref, 2);\n    var _observer = _ref2[0];\n    var observerConfig = _ref2[1];\n    _loop(observerConfig);\n  }\n};\nexport function warnNoNativePerformanceObserver() {\n  warnOnce('missing-native-performance-observer', 'Missing native implementation of PerformanceObserver');\n}\nfunction applyDurationThresholds() {\n  var durationThresholds = Array.from(registeredObservers.values()).map(function (config) {\n    return config.entryTypes;\n  }).reduce(function (accumulator, currentValue) {\n    return union(accumulator, currentValue);\n  }, new Map());\n  for (var _ref3 of durationThresholds) {\n    var _ref4 = _slicedToArray(_ref3, 2);\n    var entryType = _ref4[0];\n    var durationThreshold = _ref4[1];\n    NativePerformanceObserver == null ? void 0 : NativePerformanceObserver.setDurationThreshold(performanceEntryTypeToRaw(entryType), durationThreshold != null ? durationThreshold : 0);\n  }\n}\nvar PerformanceObserver = function () {\n  function PerformanceObserver(callback) {\n    _classCallCheck(this, PerformanceObserver);\n    this._callback = callback;\n  }\n  _createClass(PerformanceObserver, [{\n    key: \"observe\",\n    value: function observe(options) {\n      var _registeredObservers$;\n      if (!NativePerformanceObserver) {\n        warnNoNativePerformanceObserver();\n        return;\n      }\n      this._validateObserveOptions(options);\n      var requestedEntryTypes;\n      if (options.entryTypes) {\n        this._type = 'multiple';\n        requestedEntryTypes = new Map(options.entryTypes.map(function (t) {\n          return [t, undefined];\n        }));\n      } else {\n        this._type = 'single';\n        requestedEntryTypes = new Map([[options.type, options.durationThreshold]]);\n      }\n      var currentEntryTypes = (_registeredObservers$ = registeredObservers.get(this)) == null ? void 0 : _registeredObservers$.entryTypes;\n      var nextEntryTypes = currentEntryTypes ? union(requestedEntryTypes, currentEntryTypes) : requestedEntryTypes;\n      if (currentEntryTypes && currentEntryTypes.size === nextEntryTypes.size) {\n        return;\n      }\n      registeredObservers.set(this, {\n        callback: this._callback,\n        entryTypes: nextEntryTypes\n      });\n      if (!isOnPerformanceEntryCallbackSet) {\n        NativePerformanceObserver.setOnPerformanceEntryCallback(onPerformanceEntry);\n        isOnPerformanceEntryCallbackSet = true;\n      }\n      var newEntryTypes = currentEntryTypes ? difference(new Set(requestedEntryTypes.keys()), new Set(currentEntryTypes.keys())) : new Set(requestedEntryTypes.keys());\n      for (var type of newEntryTypes) {\n        var _observerCountPerEntr;\n        if (!observerCountPerEntryType.has(type)) {\n          var rawType = performanceEntryTypeToRaw(type);\n          NativePerformanceObserver.startReporting(rawType);\n        }\n        observerCountPerEntryType.set(type, ((_observerCountPerEntr = observerCountPerEntryType.get(type)) != null ? _observerCountPerEntr : 0) + 1);\n      }\n      applyDurationThresholds();\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (!NativePerformanceObserver) {\n        warnNoNativePerformanceObserver();\n        return;\n      }\n      var observerConfig = registeredObservers.get(this);\n      if (!observerConfig) {\n        return;\n      }\n      for (var type of observerConfig.entryTypes.keys()) {\n        var _observerCountPerEntr2;\n        var numberOfObserversForThisType = (_observerCountPerEntr2 = observerCountPerEntryType.get(type)) != null ? _observerCountPerEntr2 : 0;\n        if (numberOfObserversForThisType === 1) {\n          observerCountPerEntryType.delete(type);\n          NativePerformanceObserver.stopReporting(performanceEntryTypeToRaw(type));\n        } else if (numberOfObserversForThisType !== 0) {\n          observerCountPerEntryType.set(type, numberOfObserversForThisType - 1);\n        }\n      }\n      registeredObservers.delete(this);\n      if (registeredObservers.size === 0) {\n        NativePerformanceObserver.setOnPerformanceEntryCallback(undefined);\n        isOnPerformanceEntryCallbackSet = false;\n      }\n      applyDurationThresholds();\n    }\n  }, {\n    key: \"_validateObserveOptions\",\n    value: function _validateObserveOptions(options) {\n      var type = options.type,\n        entryTypes = options.entryTypes,\n        durationThreshold = options.durationThreshold;\n      if (!type && !entryTypes) {\n        throw new TypeError(\"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must not include both entryTypes and type arguments.\");\n      }\n      if (entryTypes && type) {\n        throw new TypeError(\"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must include either entryTypes or type arguments.\");\n      }\n      if (this._type === 'multiple' && type) {\n        throw new Error(\"Failed to execute 'observe' on 'PerformanceObserver': This observer has performed observe({entryTypes:...}, therefore it cannot perform observe({type:...})\");\n      }\n      if (this._type === 'single' && entryTypes) {\n        throw new Error(\"Failed to execute 'observe' on 'PerformanceObserver': This PerformanceObserver has performed observe({type:...}, therefore it cannot perform observe({entryTypes:...})\");\n      }\n      if (entryTypes && durationThreshold !== undefined) {\n        throw new TypeError(\"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must not include both entryTypes and durationThreshold arguments.\");\n      }\n    }\n  }]);\n  return PerformanceObserver;\n}();\nPerformanceObserver.supportedEntryTypes = Object.freeze(['mark', 'measure', 'event']);\nexport { PerformanceObserver as default };\nfunction union(a, b) {\n  var res = new Map();\n  for (var _ref5 of a) {\n    var _ref6 = _slicedToArray(_ref5, 2);\n    var k = _ref6[0];\n    var v = _ref6[1];\n    if (!b.has(k)) {\n      res.set(k, v);\n    } else {\n      var _b$get;\n      res.set(k, Math.min(v != null ? v : 0, (_b$get = b.get(k)) != null ? _b$get : 0));\n    }\n  }\n  return res;\n}\nfunction difference(a, b) {\n  return new Set(_toConsumableArray(a).filter(function (x) {\n    return !b.has(x);\n  }));\n}","map":{"version":3,"names":["warnOnce","NativePerformanceObserver","PerformanceEntry","performanceEntryTypeToRaw","rawToPerformanceEntry","PerformanceObserverEntryList","entries","_classCallCheck","_entries","_createClass","key","value","getEntries","getEntriesByType","type","filter","entry","entryType","getEntriesByName","name","undefined","observerCountPerEntryType","Map","registeredObservers","isOnPerformanceEntryCallbackSet","onPerformanceEntry","_entryResult$entries","entryResult","popPendingEntries","rawEntries","droppedEntriesCount","length","map","_loop","observerConfig","entriesForObserver","entryTypes","has","durationThreshold","get","duration","callback","observer","_ref","_ref2","_slicedToArray","warnNoNativePerformanceObserver","applyDurationThresholds","durationThresholds","Array","from","values","config","reduce","accumulator","currentValue","union","_ref3","_ref4","setDurationThreshold","PerformanceObserver","_callback","observe","options","_registeredObservers$","_validateObserveOptions","requestedEntryTypes","_type","t","currentEntryTypes","nextEntryTypes","size","set","setOnPerformanceEntryCallback","newEntryTypes","difference","Set","keys","_observerCountPerEntr","rawType","startReporting","disconnect","_observerCountPerEntr2","numberOfObserversForThisType","delete","stopReporting","TypeError","Error","supportedEntryTypes","Object","freeze","default","a","b","res","_ref5","_ref6","k","v","_b$get","Math","min","_toConsumableArray","x"],"sources":["D:/Users/julian/GIT/CoffeeLoyalty/FrontEnd User Mobile/node_modules/react-native/Libraries/WebPerformance/PerformanceObserver.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * @flow strict\r\n */\r\n\r\nimport type {HighResTimeStamp, PerformanceEntryType} from './PerformanceEntry';\r\n\r\nimport warnOnce from '../Utilities/warnOnce';\r\nimport NativePerformanceObserver from './NativePerformanceObserver';\r\nimport {PerformanceEntry} from './PerformanceEntry';\r\nimport {\r\n  performanceEntryTypeToRaw,\r\n  rawToPerformanceEntry,\r\n} from './RawPerformanceEntry';\r\n\r\nexport type PerformanceEntryList = $ReadOnlyArray<PerformanceEntry>;\r\n\r\nexport class PerformanceObserverEntryList {\r\n  _entries: PerformanceEntryList;\r\n\r\n  constructor(entries: PerformanceEntryList) {\r\n    this._entries = entries;\r\n  }\r\n\r\n  getEntries(): PerformanceEntryList {\r\n    return this._entries;\r\n  }\r\n\r\n  getEntriesByType(type: PerformanceEntryType): PerformanceEntryList {\r\n    return this._entries.filter(entry => entry.entryType === type);\r\n  }\r\n\r\n  getEntriesByName(\r\n    name: string,\r\n    type?: PerformanceEntryType,\r\n  ): PerformanceEntryList {\r\n    if (type === undefined) {\r\n      return this._entries.filter(entry => entry.name === name);\r\n    } else {\r\n      return this._entries.filter(\r\n        entry => entry.name === name && entry.entryType === type,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport type PerformanceObserverCallback = (\r\n  list: PerformanceObserverEntryList,\r\n  observer: PerformanceObserver,\r\n  // The number of buffered entries which got dropped from the buffer due to the buffer being full:\r\n  droppedEntryCount?: number,\r\n) => void;\r\n\r\nexport type PerformanceObserverInit =\r\n  | {\r\n      entryTypes: Array<PerformanceEntryType>,\r\n    }\r\n  | {\r\n      type: PerformanceEntryType,\r\n      durationThreshold?: HighResTimeStamp,\r\n    };\r\n\r\ntype PerformanceObserverConfig = {|\r\n  callback: PerformanceObserverCallback,\r\n  // Map of {entryType: durationThreshold}\r\n  entryTypes: $ReadOnlyMap<PerformanceEntryType, ?number>,\r\n|};\r\n\r\nconst observerCountPerEntryType: Map<PerformanceEntryType, number> = new Map();\r\nconst registeredObservers: Map<PerformanceObserver, PerformanceObserverConfig> =\r\n  new Map();\r\nlet isOnPerformanceEntryCallbackSet: boolean = false;\r\n\r\n// This is a callback that gets scheduled and periodically called from the native side\r\nconst onPerformanceEntry = () => {\r\n  if (!NativePerformanceObserver) {\r\n    return;\r\n  }\r\n  const entryResult = NativePerformanceObserver.popPendingEntries();\r\n  const rawEntries = entryResult?.entries ?? [];\r\n  const droppedEntriesCount = entryResult?.droppedEntriesCount;\r\n  if (rawEntries.length === 0) {\r\n    return;\r\n  }\r\n  const entries = rawEntries.map(rawToPerformanceEntry);\r\n  for (const [observer, observerConfig] of registeredObservers.entries()) {\r\n    const entriesForObserver: PerformanceEntryList = entries.filter(entry => {\r\n      if (!observerConfig.entryTypes.has(entry.entryType)) {\r\n        return false;\r\n      }\r\n      const durationThreshold = observerConfig.entryTypes.get(entry.entryType);\r\n      return entry.duration >= (durationThreshold ?? 0);\r\n    });\r\n    observerConfig.callback(\r\n      new PerformanceObserverEntryList(entriesForObserver),\r\n      observer,\r\n      droppedEntriesCount,\r\n    );\r\n  }\r\n};\r\n\r\nexport function warnNoNativePerformanceObserver() {\r\n  warnOnce(\r\n    'missing-native-performance-observer',\r\n    'Missing native implementation of PerformanceObserver',\r\n  );\r\n}\r\n\r\nfunction applyDurationThresholds() {\r\n  const durationThresholds: Map<PerformanceEntryType, ?number> = Array.from(\r\n    registeredObservers.values(),\r\n  )\r\n    .map(config => config.entryTypes)\r\n    .reduce(\r\n      (accumulator, currentValue) => union(accumulator, currentValue),\r\n      new Map(),\r\n    );\r\n\r\n  for (const [entryType, durationThreshold] of durationThresholds) {\r\n    NativePerformanceObserver?.setDurationThreshold(\r\n      performanceEntryTypeToRaw(entryType),\r\n      durationThreshold ?? 0,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Implementation of the PerformanceObserver interface for RN,\r\n * corresponding to the standard in https://www.w3.org/TR/performance-timeline/\r\n *\r\n * @example\r\n * const observer = new PerformanceObserver((list, _observer) => {\r\n *   const entries = list.getEntries();\r\n *   entries.forEach(entry => {\r\n *     reportEvent({\r\n *       eventName: entry.name,\r\n *       startTime: entry.startTime,\r\n *       endTime: entry.startTime + entry.duration,\r\n *       processingStart: entry.processingStart,\r\n *       processingEnd: entry.processingEnd,\r\n *       interactionId: entry.interactionId,\r\n *     });\r\n *   });\r\n * });\r\n * observer.observe({ type: \"event\" });\r\n */\r\nexport default class PerformanceObserver {\r\n  _callback: PerformanceObserverCallback;\r\n  _type: 'single' | 'multiple' | void;\r\n\r\n  constructor(callback: PerformanceObserverCallback) {\r\n    this._callback = callback;\r\n  }\r\n\r\n  observe(options: PerformanceObserverInit): void {\r\n    if (!NativePerformanceObserver) {\r\n      warnNoNativePerformanceObserver();\r\n      return;\r\n    }\r\n\r\n    this._validateObserveOptions(options);\r\n\r\n    let requestedEntryTypes;\r\n\r\n    if (options.entryTypes) {\r\n      this._type = 'multiple';\r\n      requestedEntryTypes = new Map(\r\n        options.entryTypes.map(t => [t, undefined]),\r\n      );\r\n    } else {\r\n      this._type = 'single';\r\n      requestedEntryTypes = new Map([\r\n        [options.type, options.durationThreshold],\r\n      ]);\r\n    }\r\n\r\n    // The same observer may receive multiple calls to \"observe\", so we need\r\n    // to check what is new on this call vs. previous ones.\r\n    const currentEntryTypes = registeredObservers.get(this)?.entryTypes;\r\n    const nextEntryTypes = currentEntryTypes\r\n      ? union(requestedEntryTypes, currentEntryTypes)\r\n      : requestedEntryTypes;\r\n\r\n    // This `observe` call is a no-op because there are no new things to observe.\r\n    if (currentEntryTypes && currentEntryTypes.size === nextEntryTypes.size) {\r\n      return;\r\n    }\r\n\r\n    registeredObservers.set(this, {\r\n      callback: this._callback,\r\n      entryTypes: nextEntryTypes,\r\n    });\r\n\r\n    if (!isOnPerformanceEntryCallbackSet) {\r\n      NativePerformanceObserver.setOnPerformanceEntryCallback(\r\n        onPerformanceEntry,\r\n      );\r\n      isOnPerformanceEntryCallbackSet = true;\r\n    }\r\n\r\n    // We only need to start listenening to new entry types being observed in\r\n    // this observer.\r\n    const newEntryTypes = currentEntryTypes\r\n      ? difference(\r\n          new Set(requestedEntryTypes.keys()),\r\n          new Set(currentEntryTypes.keys()),\r\n        )\r\n      : new Set(requestedEntryTypes.keys());\r\n    for (const type of newEntryTypes) {\r\n      if (!observerCountPerEntryType.has(type)) {\r\n        const rawType = performanceEntryTypeToRaw(type);\r\n        NativePerformanceObserver.startReporting(rawType);\r\n      }\r\n      observerCountPerEntryType.set(\r\n        type,\r\n        (observerCountPerEntryType.get(type) ?? 0) + 1,\r\n      );\r\n    }\r\n    applyDurationThresholds();\r\n  }\r\n\r\n  disconnect(): void {\r\n    if (!NativePerformanceObserver) {\r\n      warnNoNativePerformanceObserver();\r\n      return;\r\n    }\r\n\r\n    const observerConfig = registeredObservers.get(this);\r\n    if (!observerConfig) {\r\n      return;\r\n    }\r\n\r\n    // Disconnect this observer\r\n    for (const type of observerConfig.entryTypes.keys()) {\r\n      const numberOfObserversForThisType =\r\n        observerCountPerEntryType.get(type) ?? 0;\r\n      if (numberOfObserversForThisType === 1) {\r\n        observerCountPerEntryType.delete(type);\r\n        NativePerformanceObserver.stopReporting(\r\n          performanceEntryTypeToRaw(type),\r\n        );\r\n      } else if (numberOfObserversForThisType !== 0) {\r\n        observerCountPerEntryType.set(type, numberOfObserversForThisType - 1);\r\n      }\r\n    }\r\n\r\n    // Disconnect all observers if this was the last one\r\n    registeredObservers.delete(this);\r\n    if (registeredObservers.size === 0) {\r\n      NativePerformanceObserver.setOnPerformanceEntryCallback(undefined);\r\n      isOnPerformanceEntryCallbackSet = false;\r\n    }\r\n\r\n    applyDurationThresholds();\r\n  }\r\n\r\n  _validateObserveOptions(options: PerformanceObserverInit): void {\r\n    const {type, entryTypes, durationThreshold} = options;\r\n\r\n    if (!type && !entryTypes) {\r\n      throw new TypeError(\r\n        \"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must not include both entryTypes and type arguments.\",\r\n      );\r\n    }\r\n\r\n    if (entryTypes && type) {\r\n      throw new TypeError(\r\n        \"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must include either entryTypes or type arguments.\",\r\n      );\r\n    }\r\n\r\n    if (this._type === 'multiple' && type) {\r\n      throw new Error(\r\n        \"Failed to execute 'observe' on 'PerformanceObserver': This observer has performed observe({entryTypes:...}, therefore it cannot perform observe({type:...})\",\r\n      );\r\n    }\r\n\r\n    if (this._type === 'single' && entryTypes) {\r\n      throw new Error(\r\n        \"Failed to execute 'observe' on 'PerformanceObserver': This PerformanceObserver has performed observe({type:...}, therefore it cannot perform observe({entryTypes:...})\",\r\n      );\r\n    }\r\n\r\n    if (entryTypes && durationThreshold !== undefined) {\r\n      throw new TypeError(\r\n        \"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must not include both entryTypes and durationThreshold arguments.\",\r\n      );\r\n    }\r\n  }\r\n\r\n  static supportedEntryTypes: $ReadOnlyArray<PerformanceEntryType> =\r\n    Object.freeze(['mark', 'measure', 'event']);\r\n}\r\n\r\n// As a Set union, except if value exists in both, we take minimum\r\nfunction union<T>(\r\n  a: $ReadOnlyMap<T, ?number>,\r\n  b: $ReadOnlyMap<T, ?number>,\r\n): Map<T, ?number> {\r\n  const res = new Map<T, ?number>();\r\n  for (const [k, v] of a) {\r\n    if (!b.has(k)) {\r\n      res.set(k, v);\r\n    } else {\r\n      res.set(k, Math.min(v ?? 0, b.get(k) ?? 0));\r\n    }\r\n  }\r\n  return res;\r\n}\r\n\r\nfunction difference<T>(a: $ReadOnlySet<T>, b: $ReadOnlySet<T>): Set<T> {\r\n  return new Set([...a].filter(x => !b.has(x)));\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}