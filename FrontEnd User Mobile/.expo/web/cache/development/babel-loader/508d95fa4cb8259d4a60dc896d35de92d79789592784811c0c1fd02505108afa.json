{"ast":null,"code":"import { useCallback, useRef } from 'react';\nexport default function useRefEffect(effect) {\n  var cleanupRef = useRef(undefined);\n  return useCallback(function (instance) {\n    if (cleanupRef.current) {\n      cleanupRef.current();\n      cleanupRef.current = undefined;\n    }\n    if (instance != null) {\n      cleanupRef.current = effect(instance);\n    }\n  }, [effect]);\n}","map":{"version":3,"names":["useCallback","useRef","useRefEffect","effect","cleanupRef","undefined","instance","current"],"sources":["D:/Users/julian/GIT/CoffeeLoyalty/FrontEnd User Mobile/node_modules/react-native/Libraries/Utilities/useRefEffect.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict\r\n * @format\r\n */\r\n\r\nimport {useCallback, useRef} from 'react';\r\n\r\ntype CallbackRef<T> = T => mixed;\r\n\r\n/**\r\n * Constructs a callback ref that provides similar semantics as `useEffect`. The\r\n * supplied `effect` callback will be called with non-null component instances.\r\n * The `effect` callback can also optionally return a cleanup function.\r\n *\r\n * When a component is updated or unmounted, the cleanup function is called. The\r\n * `effect` callback will then be called again, if applicable.\r\n *\r\n * When a new `effect` callback is supplied, the previously returned cleanup\r\n * function will be called before the new `effect` callback is called with the\r\n * same instance.\r\n *\r\n * WARNING: The `effect` callback should be stable (e.g. using `useCallback`).\r\n */\r\nexport default function useRefEffect<TInstance>(\r\n  effect: TInstance => (() => void) | void,\r\n): CallbackRef<TInstance | null> {\r\n  const cleanupRef = useRef<(() => void) | void>(undefined);\r\n  return useCallback(\r\n    (instance: null | TInstance) => {\r\n      if (cleanupRef.current) {\r\n        cleanupRef.current();\r\n        cleanupRef.current = undefined;\r\n      }\r\n      if (instance != null) {\r\n        cleanupRef.current = effect(instance);\r\n      }\r\n    },\r\n    [effect],\r\n  );\r\n}\r\n"],"mappings":"AAUA,SAAQA,WAAW,EAAEC,MAAM,QAAO,OAAO;AAkBzC,eAAe,SAASC,YAAYA,CAClCC,MAAwC,EACT;EAC/B,IAAMC,UAAU,GAAGH,MAAM,CAAsBI,SAAS,CAAC;EACzD,OAAOL,WAAW,CAChB,UAACM,QAA0B,EAAK;IAC9B,IAAIF,UAAU,CAACG,OAAO,EAAE;MACtBH,UAAU,CAACG,OAAO,CAAC,CAAC;MACpBH,UAAU,CAACG,OAAO,GAAGF,SAAS;IAChC;IACA,IAAIC,QAAQ,IAAI,IAAI,EAAE;MACpBF,UAAU,CAACG,OAAO,GAAGJ,MAAM,CAACG,QAAQ,CAAC;IACvC;EACF,CAAC,EACD,CAACH,MAAM,CACT,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}